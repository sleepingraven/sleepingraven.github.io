<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MapReduce 编程实践</title>
      <link href="practice/mapreduce-bian-cheng-shi-jian/"/>
      <url>practice/mapreduce-bian-cheng-shi-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MapReduce 采用了「分而治之」的思想。在分布式计算中，MapReduce 框架负责处理并行编程中分布式存储、工作调度、负载均衡、容错均衡、容错处理以及网络通信等复杂问题，把处理过程高度抽象为两个函数：map，把一个任务分解成多个任务；reduce，将任务的处理结果汇总。MapReduce 处理的数据集（或任务）必须具备这样的特点：待处理的数据集可以分解成许多小的数据集，而且每一个小数据集都可以完全并行地进行处理。</p><p>在 Hadoop 中，每个 MapReduce 任务都被初始化为一个 Job，每个 Job 又可以分为两种阶段：map 阶段和 reduce 阶段，分别用两个函数表示。map 函数接收一个 &lt;key, value&gt; 形式的输入，同样产生一个 &lt;key, value&gt; 形式的输出；Hadoop 函数接收一个如 &lt;key, List<value>&gt; 形式的输入，然后对 list 进行处理，每个 reduce 产生 0 或 1 个输出，reduce 的输出也是 &lt;key, value&gt; 形式的。</value></p></blockquote><h2 id="数据去重"><a href="# 数据去重" class="headerlink" title="数据去重"></a>数据去重 </h2><h3 id="编写测试文件并上传"><a href="# 编写测试文件并上传" class="headerlink" title="编写测试文件并上传"></a> 编写测试文件并上传</h3><p><img src="/practice/mapreduce-bian-cheng-shi-jian/1.1-1-cat.png" alt="cat"></p><p><img src="/practice/mapreduce-bian-cheng-shi-jian/1.1-2-put.png" alt="put"></p><h3 id="上传 jar 包，执行程序"><a href="# 上传 jar 包，执行程序" class="headerlink" title="上传 jar 包，执行程序"></a>上传 jar 包，执行程序</h3><p><img src="/practice/mapreduce-bian-cheng-shi-jian/1.2-jar.png" alt="jar"></p><h3 id="查看输出文件"><a href="# 查看输出文件" class="headerlink" title="查看输出文件"></a>查看输出文件</h3><p><img src="/practice/mapreduce-bian-cheng-shi-jian/1.3-cat.png" alt="cat"></p><h2 id="数据排序"><a href="# 数据排序" class="headerlink" title="数据排序"></a>数据排序 </h2><h3 id="编写测试文件并上传 -1"><a href="# 编写测试文件并上传 -1" class="headerlink" title="编写测试文件并上传"></a> 编写测试文件并上传</h3><p><img src="/practice/mapreduce-bian-cheng-shi-jian/2.1-1-cat.png" alt="cat"></p><p><img src="/practice/mapreduce-bian-cheng-shi-jian/2.1-2-put.png" alt="put"></p><h3 id="上传 jar 包，执行程序 -1"><a href="# 上传 jar 包，执行程序 -1" class="headerlink" title="上传 jar 包，执行程序"></a>上传 jar 包，执行程序</h3><p><img src="/practice/mapreduce-bian-cheng-shi-jian/2.2-jar.png" alt="jar"></p><h3 id="查看输出文件 -1"><a href="# 查看输出文件 -1" class="headerlink" title="查看输出文件"></a>查看输出文件</h3><p><img src="/practice/mapreduce-bian-cheng-shi-jian/2.3-cat.png" alt="cat"></p><h2 id="单表关联"><a href="# 单表关联" class="headerlink" title="单表关联"></a>单表关联 </h2><h3 id="编写测试文件并上传 -2"><a href="# 编写测试文件并上传 -2" class="headerlink" title="编写测试文件并上传"></a> 编写测试文件并上传</h3><p><img src="/practice/mapreduce-bian-cheng-shi-jian/3.1-cat.png" alt="cat"></p><h3 id="上传 jar 包，执行程序 -2"><a href="# 上传 jar 包，执行程序 -2" class="headerlink" title="上传 jar 包，执行程序"></a>上传 jar 包，执行程序</h3><p><img src="/practice/mapreduce-bian-cheng-shi-jian/3.2-jar.png" alt="jar"></p><h3 id="查看输出文件 -2"><a href="# 查看输出文件 -2" class="headerlink" title="查看输出文件"></a>查看输出文件</h3><p><img src="/practice/mapreduce-bian-cheng-shi-jian/3.3-cat.png" alt="cat"></p><h2 id="参考代码"><a href="# 参考代码" class="headerlink" title="参考代码"></a>参考代码 </h2><h3 id="数据去重 -1"><a href="# 数据去重 -1" class="headerlink" title="数据去重"></a> 数据去重</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoveDeduplication</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * map 将输入中的 value 复制到输出数据的 key 上，并直接输出     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Map</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token comment">// 每行数据</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Text</span> line <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>            line <span class="token operator">=</span> value<span class="token punctuation">;</span>            context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * reduce 将输入中的 key 复制到输出数据的 key 上，并直接输出     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Reduce</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">&gt;</span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>            context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Configuration</span> conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 这句话很关键</span>        <span class="token comment">// conf.set("mapred.job.tracker", "192.168.1.2:9001");</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> otherArgs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericOptionsParser</span><span class="token punctuation">(</span>conf<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRemainingArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherArgs<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Usage: Data Deduplication &lt;in&gt; &lt;out&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Job</span> job <span class="token operator">=</span> <span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>conf<span class="token punctuation">,</span> <span class="token string">"Data Deduplication"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">RemoveDeduplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置 Map、Combine 和 Reduce 处理类</span>        job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setCombinerClass</span><span class="token punctuation">(</span><span class="token class-name">Reduce</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">Reduce</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置输出类型</span>        job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置输入和输出目录</span>        <span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">addInputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>otherArgs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>otherArgs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据排序 -1"><a href="# 数据排序 -1" class="headerlink" title="数据排序"></a>数据排序</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataSort</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * map 将输入中的 value 化成 IntWritable 类型，作为输出的 key     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Map</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">IntWritable</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> line <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            data<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * reduce 将输入中的 key 复制到输出数据的 key 上，然后根据输入的 value-list 中元素的个数决定 key 的输出次数。     * 用全局 lineNum 来代表 key 的位次     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Reduce</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IntWritable</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">,</span> <span class="token class-name">IntWritable</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">IntWritable</span> lineNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">IntWritable</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IntWritable</span><span class="token punctuation">&gt;</span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span>                <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">IntWritable</span> val <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>                context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>lineNum<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>                lineNum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span>lineNum<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Configuration</span> conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 这句话很关键</span>        <span class="token comment">// conf.set("mapred.job.tracker", "192.168.1.2:9001");</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> otherArgs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericOptionsParser</span><span class="token punctuation">(</span>conf<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRemainingArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherArgs<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Usage: Data Sort &lt;in&gt; &lt;out&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Job</span> job <span class="token operator">=</span> <span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>conf<span class="token punctuation">,</span> <span class="token string">"Data Sort"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">DataSort</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置 Map 和 Reduce 处理类</span>        job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">Reduce</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置输出类型</span>        job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">IntWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">IntWritable</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置输入和输出目录</span>        <span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">addInputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>otherArgs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>otherArgs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单表关联 -1"><a href="# 单表关联 -1" class="headerlink" title="单表关联"></a>单表关联</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleTableJoin</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/**     * map 将输出分割 child 和 parent，然后正序输出一次作为右表，     * 反序输出一次作为左表，需要注意的是在输出的 value 中必须加上左右表的区别标识。     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Map</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> childName<span class="token punctuation">;</span>            <span class="token class-name">String</span> parentName<span class="token punctuation">;</span>            <span class="token comment">// 左右表标识</span>            <span class="token class-name">String</span> relationType<span class="token punctuation">;</span>            <span class="token comment">// 输入的一行预处理文本</span>            <span class="token class-name">StringTokenizer</span> itr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> itr<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                values<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> itr<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token string">"child"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                childName <span class="token operator">=</span> values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                parentName <span class="token operator">=</span> values<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 输出左表</span>                relationType <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span>                context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>values<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>relationType <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> childName <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> parentName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 输出右表</span>                relationType <span class="token operator">=</span> <span class="token string">"2"</span><span class="token punctuation">;</span>                context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>relationType <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> childName <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> parentName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Reduce</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">&gt;</span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>            <span class="token comment">// 输出表头</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>                context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string">"grandchild"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string">"grandparent"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                time<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> grandchildnum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grandchild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> grandparentnum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grandparent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Text</span> value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">String</span> <span class="token keyword">record</span> <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 取得左右表标识</span>                <span class="token keyword">char</span> relationType <span class="token operator">=</span> <span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 定义孩子和父母变量</span>                <span class="token class-name">StringBuilder</span> childName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">StringBuilder</span> parentName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 获取 value-list 中 value 的 child</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'+'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    childName<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">// 获取 value-list 中 value 的 parent</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    parentName<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 左表，取出 child 放入 grandchildren</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'1'</span> <span class="token operator">==</span> relationType<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    grandchild<span class="token punctuation">[</span>grandchildnum<span class="token punctuation">]</span> <span class="token operator">=</span> childName<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    grandchildnum<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 右表，取出 parent 放入 grandparent</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'2'</span> <span class="token operator">==</span> relationType<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    grandparent<span class="token punctuation">[</span>grandparentnum<span class="token punctuation">]</span> <span class="token operator">=</span> parentName<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    grandparentnum<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">// grandchild 和 grandparent 数组求笛卡尔儿积</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> grandchildnum <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">!=</span> grandparentnum<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> m <span class="token operator">&lt;</span> grandchildnum<span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> grandparentnum<span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 输出结果</span>                        context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>grandchild<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>grandparent<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Configuration</span> conf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Configuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 这句话很关键</span>        <span class="token comment">// conf.set("mapred.job.tracker", "192.168.1.2:9001");</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> otherArgs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericOptionsParser</span><span class="token punctuation">(</span>conf<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRemainingArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherArgs<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Usage: Single Table Join &lt;in&gt; &lt;out&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Job</span> job <span class="token operator">=</span> <span class="token class-name">Job</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>conf<span class="token punctuation">,</span> <span class="token string">"Single Table Join"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span><span class="token class-name">SimpleTableJoin</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置 Map 和 Reduce 处理类</span>        job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span><span class="token class-name">Reduce</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置输出类型</span>        job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置输入和输出目录</span>        <span class="token class-name">FileInputFormat</span><span class="token punctuation">.</span><span class="token function">addInputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>otherArgs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileOutputFormat</span><span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>otherArgs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考链接"><a href="# 参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/wang_zhenwei/article/details/48086211">CentOS 系统下的 Hadoop 集群（第 9 期）_MapReduce 初级案例_wang_zhenwei 的博客 -CSDN 博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop 大数据平台搭建</title>
      <link href="practice/hadoop-da-shu-ju-ping-tai-da-jian/"/>
      <url>practice/hadoop-da-shu-ju-ping-tai-da-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hadoop 由 Apache Software Foundation 公司于 2005 年秋天作为 Lucene 的子项目 Nutch 的一部分正式引入。它受到论文 MapReduce 、GFS 与 Bigtable 的启发。</p><p>Hadoop 具有高可靠性、高扩展性、高效性和高容错性。Hadoop 主要由以下四部分组成：HDFS，一个高可靠、高吞吐量的分布式文件系统；MapReduce，一个分布式的离线并行计算框架；YARN，作业调度与集群资源管理的框架；Common，工具模块，支持配置、RPC、序列化机制、日志操作等。</p></blockquote><h2 id="部署规划"><a href="# 部署规划" class="headerlink" title="部署规划"></a>部署规划</h2><table><thead><tr><th>主机名称</th><th>IP</th><th>HDFS</th><th>Yarn</th><th>内存</th></tr></thead><tbody><tr><td>hadoop-01</td><td>192.168.226.137</td><td>NameNode SecondaryNameNode DataNode</td><td>ResourceManager NodeManager</td><td>1G</td></tr><tr><td>hadoop-02</td><td>192.168.226.138</td><td>DataNode</td><td>NodeManager</td><td>1G</td></tr><tr><td>Hadoop-03</td><td>192.168.226.139</td><td>DataNode</td><td>NodeManager</td><td>1G</td></tr></tbody></table><h2 id="网络配置，创建用户"><a href="# 网络配置，创建用户" class="headerlink" title="网络配置，创建用户"></a>网络配置，创建用户</h2><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/2-1-net.png" alt="net"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/2-2-user.png" alt="user"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/2-3-sudo.png" alt="sudo"></p><h2 id="安装 JDK 和 Hadoop"><a href="# 安装 JDK 和 Hadoop" class="headerlink" title="安装 JDK 和 Hadoop"></a>安装 JDK 和 Hadoop</h2><h3 id="解压二进制资源包，配置环境变量"><a href="# 解压二进制资源包，配置环境变量" class="headerlink" title="解压二进制资源包，配置环境变量"></a>解压二进制资源包，配置环境变量</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/3.1-path.png" alt="path"></p><h3 id="验证安装"><a href="# 验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/3.2-1-version.png" alt="version"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/3.2-2-hadoop.png" alt="hadoop"></p><h2 id="设置防火墙、修改 hosts"><a href="# 设置防火墙、修改 hosts" class="headerlink" title="设置防火墙、修改 hosts"></a>设置防火墙、修改 hosts</h2><h2 id="环境与用户配置"><a href="# 环境与用户配置" class="headerlink" title="环境与用户配置"></a>环境与用户配置</h2><h3 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a>hadoop-env.sh</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/5.1-hadoop-env.png" alt="hadoop-env"></p><h3 id="start-dfs-sh"><a href="#start-dfs-sh" class="headerlink" title="start-dfs.sh"></a>start-dfs.sh</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/5.2-start-dfs.png" alt="start-dfs"></p><h3 id="start-yarn-sh"><a href="#start-yarn-sh" class="headerlink" title="start-yarn.sh"></a>start-yarn.sh</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/5.3-start-yarn.png" alt="start-yarn"></p><h2 id="参数配置"><a href="# 参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/6.1-core-site.png" alt="core-site"></p><h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/6.2-hdfs-site.png" alt="hdfs-site"></p><h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/6.3-mapred-site.png" alt="mapred-site"></p><h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/6.4-yarn-site.png" alt="yarn-site"></p><h2 id="格式化 namenode"><a href="# 格式化 namenode" class="headerlink" title="格式化 namenode"></a>格式化 namenode</h2><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/7-1-namenode-format.png" alt="namenode-format"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/7-2-namenode-format.png" alt="namenode-format"></p><h2 id="ssh 免密登录"><a href="#ssh 免密登录" class="headerlink" title="ssh 免密登录"></a>ssh 免密登录</h2><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/8-ssh.png" alt="ssh"></p><h2 id="启动 Hadoop"><a href="# 启动 Hadoop" class="headerlink" title="启动 Hadoop"></a>启动 Hadoop</h2><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/9.1-start.png" alt="start"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/9.2-overview.png" alt="overview"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/9.3-cluster.png" alt="cluster"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/9.4-node.png" alt="node"></p><h2 id="用 hadoop-01 克隆两台虚拟机"><a href="# 用 hadoop-01 克隆两台虚拟机" class="headerlink" title="用 hadoop-01 克隆两台虚拟机"></a>用 hadoop-01 克隆两台虚拟机 </h2><h3 id="配置网络，修改主机名"><a href="# 配置网络，修改主机名" class="headerlink" title="配置网络，修改主机名"></a> 配置网络，修改主机名</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/10.1-clone.png" alt="clone"></p><h3 id="分别添加 ssh 公钥"><a href="# 分别添加 ssh 公钥" class="headerlink" title="分别添加 ssh 公钥"></a>分别添加 ssh 公钥</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/10.2-1-ssh.png" alt="ssh"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/10.2-2-ssh-copy.png" alt="ssh-copy"></p><h2 id="修改参数"><a href="# 修改参数" class="headerlink" title="修改参数"></a>修改参数</h2><h3 id="workers"><a href="#workers" class="headerlink" title="workers"></a>workers</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/11.1-workers.png" alt="workers"></p><h3 id="hdfs-site-xml-1"><a href="#hdfs-site-xml-1" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/11.2-hdfs-site.png" alt="hdfs-site"></p><h3 id="yarn-site-xml-1"><a href="#yarn-site-xml-1" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/11.3-yarn-site.png" alt="yarn-site"></p><h3 id="mapred-site-xml-1"><a href="#mapred-site-xml-1" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/11.4-mapred-site.png" alt="mapred-site"></p><h2 id="格式化 namenode 并启动"><a href="# 格式化 namenode 并启动" class="headerlink" title="格式化 namenode 并启动"></a>格式化 namenode 并启动</h2><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/12-1-jps02.png" alt="jps02"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/12-2-jps03.png" alt="jps03"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/12-3-start-all.png" alt="start-all"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/12-4-node.png" alt="node"></p><h2 id="测试 wordcount 实例"><a href="# 测试 wordcount 实例" class="headerlink" title="测试 wordcount 实例"></a>测试 wordcount 实例 </h2><h3 id="创建测试文件"><a href="# 创建测试文件" class="headerlink" title="创建测试文件"></a> 创建测试文件</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/13.1-words.png" alt="words"></p><h3 id="执行程序"><a href="# 执行程序" class="headerlink" title="执行程序"></a>执行程序</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/13.2-jar.png" alt="jar"></p><h3 id="同步时间"><a href="# 同步时间" class="headerlink" title="同步时间"></a>同步时间</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/13.3-ntpd.png" alt="ntpd"></p><h3 id="再次执行"><a href="# 再次执行" class="headerlink" title="再次执行"></a>再次执行</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/13.4-jar.png" alt="jar"></p><h3 id="修改 mapred-site-xml"><a href="# 修改 mapred-site-xml" class="headerlink" title="修改 mapred-site.xml"></a>修改 mapred-site.xml</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/13.5-mapred-site.png" alt="mapred-site"></p><h3 id="再次执行 -1"><a href="# 再次执行 -1" class="headerlink" title="再次执行"></a>再次执行</h3><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/13.6-1-jar.png" alt="jar"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/13.6-2-directory.png" alt="directory"></p><p><img src="/practice/hadoop-da-shu-ju-ping-tai-da-jian/13.6-3-cat.png" alt="cat"></p><h2 id="参考链接"><a href="# 参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/de4d56433848">Hadoop 3.2 环境搭建 - 简书</a></p>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack 开源云计算平台搭建</title>
      <link href="practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/"/>
      <url>practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>OpenStack 是一个旨在为公共及私有云的建设与管理提供软件的开源项目，其首要任务是简化云的部署过程并为其带来良好的可扩展性。</p><p>OpenStack 云计算平台，帮助服务商和企业内部实现类似于 Amazon EC2 和 S3 的云基础架构服务（Infrastructure as a Service，IaaS）。OpenStack 包含两个主要模块：Nova 和 Swift，前者是 NASA 开发的虚拟服务器部署和业务计算模块；后者是 Rackspace 开发的分布式云存储模块。本文安装了 nova 等模块。</p></blockquote><p>本文演示了部署效果，参考链接中包含详细的配置</p><h2 id="部署环境"><a href="# 部署环境" class="headerlink" title="部署环境"></a>部署环境 </h2><h3 id="主机信息"><a href="# 主机信息" class="headerlink" title="主机信息"></a> 主机信息</h3><table><thead><tr><th>主机名称</th><th>IP</th><th>角色</th><th>系统版本</th><th>内存</th></tr></thead><tbody><tr><td>controller</td><td>192.168.226.132</td><td>控制器</td><td>CentOS-7-x86_64-DVD-1908</td><td>2G</td></tr><tr><td>compute</td><td>192.168.226.131</td><td>计算节点</td><td>CentOS-7-x86_64-DVD-1908</td><td>2G</td></tr></tbody></table><h3 id="时间同步与 yum 源"><a href="# 时间同步与 yum 源" class="headerlink" title="时间同步与 yum 源"></a>时间同步与 yum 源</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/1.2-1-chronyc&amp;yum.png" alt="时间同步与 yum 源"></p><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/1.2-2-chronyc.png" alt="yum 源"></p><h2 id="安装配置数据库服务（MySQL）"><a href="# 安装配置数据库服务（MySQL）" class="headerlink" title="安装配置数据库服务（MySQL）"></a>安装配置数据库服务（MySQL）</h2><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/2-MySQL.png" alt="MySQL"></p><h2 id="安装配置消息队列服务（RabbitMQ）"><a href="# 安装配置消息队列服务（RabbitMQ）" class="headerlink" title="安装配置消息队列服务（RabbitMQ）"></a>安装配置消息队列服务（RabbitMQ）</h2><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/3-RabbitMQ.png" alt="RabbitMQ"></p><h2 id="安装和配置 OpenStack 身份认证服务"><a href="# 安装和配置 OpenStack 身份认证服务" class="headerlink" title="安装和配置 OpenStack 身份认证服务"></a>安装和配置 OpenStack 身份认证服务</h2><p>（代码名称 keystone。出于性能原因，配置部署 Apache HTTP 服务处理查询并使用 Memcached 存储 tokens 而不用 SQL 数据库）</p><h3 id="创建数据库及授权"><a href="# 创建数据库及授权" class="headerlink" title="创建数据库及授权"></a>创建数据库及授权</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/4.1-database&amp;grant.png" alt="database &amp; grant"></p><h3 id="启动服务"><a href="# 启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/4.2-start-service.png" alt="start service"></p><h3 id="服务实体和 API 端点"><a href="# 服务实体和 API 端点" class="headerlink" title="服务实体和 API 端点"></a>服务实体和 API 端点</h3><p>（每个添加到 OpenStack 环境中的服务要求一个或多个服务实体和三个认证服务中的 API 端点变种）</p><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/4.3-1-openstack-service.png" alt="openstack service"></p><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/4.3-2-start-endpoint.png" alt="openstack endpoint"></p><h3 id="为进行管理操作，创建管理的项目、用户和角色"><a href="# 为进行管理操作，创建管理的项目、用户和角色" class="headerlink" title="为进行管理操作，创建管理的项目、用户和角色"></a>为进行管理操作，创建管理的项目、用户和角色</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/4.4-openstack-project&amp;user&amp;role.png" alt="openstack -project &amp; user &amp; role-"></p><h3 id="创建 admin 和 demo 项目和用户创建客户端环境变量脚本 OpenRC 文件，为客户端操作加载合适的凭证"><a href="# 创建 admin 和 demo 项目和用户创建客户端环境变量脚本 OpenRC 文件，为客户端操作加载合适的凭证" class="headerlink" title="创建 admin 和 demo 项目和用户创建客户端环境变量脚本 OpenRC 文件，为客户端操作加载合适的凭证"></a>创建 admin 和 demo 项目和用户创建客户端环境变量脚本 OpenRC 文件，为客户端操作加载合适的凭证</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/4.5-openstack-admin&amp;demo.png" alt="openstack -admin &amp; demo-"></p><h2 id="添加镜像服务"><a href="# 添加镜像服务" class="headerlink" title="添加镜像服务"></a>添加镜像服务 </h2><h3 id="服务安装"><a href="# 服务安装" class="headerlink" title="服务安装"></a> 服务安装</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/5.1-service.png" alt="service"></p><h3 id="确认镜像的上传并验证属性"><a href="# 确认镜像的上传并验证属性" class="headerlink" title="确认镜像的上传并验证属性"></a>确认镜像的上传并验证属性</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/5.2-galance.png" alt="galance"></p><h2 id="安装和配置 compute 服务，即 nova"><a href="# 安装和配置 compute 服务，即 nova" class="headerlink" title="安装和配置 compute 服务，即 nova"></a>安装和配置 compute 服务，即 nova</h2><h3 id="列出服务组件，以验证是否成功启动并注册了每个进程；列出镜像服务目录的镜像，验证镜像服务的连通性"><a href="# 列出服务组件，以验证是否成功启动并注册了每个进程；列出镜像服务目录的镜像，验证镜像服务的连通性" class="headerlink" title="列出服务组件，以验证是否成功启动并注册了每个进程；列出镜像服务目录的镜像，验证镜像服务的连通性"></a>列出服务组件，以验证是否成功启动并注册了每个进程；列出镜像服务目录的镜像，验证镜像服务的连通性</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/6.1-nova.png" alt="nova"></p><h2 id="安装和配置网络服务（neutron）"><a href="# 安装和配置网络服务（neutron）" class="headerlink" title="安装和配置网络服务（neutron）"></a>安装和配置网络服务（neutron）</h2><h3 id="列出加载的扩展，对 neutron-server 进程是否启动正常进行验证"><a href="# 列出加载的扩展，对 neutron-server 进程是否启动正常进行验证" class="headerlink" title="列出加载的扩展，对 neutron-server 进程是否启动正常进行验证"></a>列出加载的扩展，对 neutron-server 进程是否启动正常进行验证</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/7.1-neutorn.png" alt="neutorn"></p><h3 id="列出代理以验证启动 neutron 代理是否成功 - 该输出应该显示在控制节点上有四个代理，在每个计算节点上有一个代理"><a href="# 列出代理以验证启动 neutron 代理是否成功 - 该输出应该显示在控制节点上有四个代理，在每个计算节点上有一个代理" class="headerlink" title="列出代理以验证启动 neutron 代理是否成功 , 该输出应该显示在控制节点上有四个代理，在每个计算节点上有一个代理"></a>列出代理以验证启动 neutron 代理是否成功 , 该输出应该显示在控制节点上有四个代理，在每个计算节点上有一个代理</h3><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/7.2-neutorn-agent.png" alt="neutorn agent"></p><h2 id="启动一个实例"><a href="# 启动一个实例" class="headerlink" title="启动一个实例"></a>启动一个实例</h2><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/8-1-net-list.png" alt="net list"></p><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/8-2-router.png" alt="router"></p><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/8-3-ping.png" alt="ping"></p><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/8-4-key&amp;image.png" alt="key &amp; image"></p><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/8-5-list.png" alt="list"></p><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/8-6-terminal.png" alt="terminal"></p><h2 id="添加仪表盘（dashboard）"><a href="# 添加仪表盘（dashboard）" class="headerlink" title="添加仪表盘（dashboard）"></a>添加仪表盘（dashboard）</h2><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/9-1-dashboard.png" alt="dashboard"></p><p><img src="/practice/openstack-kai-yuan-yun-ji-suan-ping-tai-da-jian/9-2-dashboard-images.png" alt="dashboard images"></p><h2 id="参考链接"><a href="# 参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/panwenbin-logs/p/8410551.html">CentOS7.4 安装部署 openstack [Liberty 版] （一） - 百衲本 - 博客园</a></p><p><a href="https://www.cnblogs.com/fa-learning/p/9187258.html">CentOS7 和 OpenStack 的笔记（一） - FA-learning - 博客园</a></p><p><a href="https://www.cnblogs.com/liang2580/articles/8157963.html">Centos7.3 部署 openstack ocata 详解 - crazy_py - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试技术</title>
      <link href="notes/ruan-jian-ce-shi-ji-zhu/"/>
      <url>notes/ruan-jian-ce-shi-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h2 id="软件测试的定义"><a href="# 软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义 </h2><h3 id="软件测试是一个过程或一系列过程，用来确认计算机代码完成了其应该完成的功能，不执行其不该有的操作。"><a href="# 软件测试是一个过程或一系列过程，用来确认计算机代码完成了其应该完成的功能，不执行其不该有的操作。" class="headerlink" title="软件测试是一个过程或一系列过程，用来确认计算机代码完成了其应该完成的功能，不执行其不该有的操作。"></a> 软件测试是一个过程或一系列过程，用来确认计算机代码完成了其应该完成的功能，不执行其不该有的操作。</h3><h3 id="软件测试与调试的区别？"><a href="# 软件测试与调试的区别？" class="headerlink" title="软件测试与调试的区别？"></a>软件测试与调试的区别？</h3><ul><li>测试是为了发现软件中存在的错误；调试是为证明软件开发的正确性。</li><li>测试以已知条件开始，使用预先定义的程序，且有预知的结果，不可预见的仅是程序是否通过测试；调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。</li><li>测试是有计划的，需要进行测试设计；调试是不受时间约束的。</li><li>测试经历发现错误、改正错误、重新测试的过程；调试是一个推理过程。</li><li>测试的执行是有规程的；调试的执行往往要求开发人员进行必要推理以至知觉的“飞跃”。</li><li>测试经常是由独立的测试组在不了解软件设计的条件下完成的；调试必须由了解详细设计的开发人员完成。</li><li>大多数测试的执行和设计可以由工具支持；调式时，开发人员能利用的工具主要是调试器。</li></ul><h3 id="对软件测试的理解？"><a href="# 对软件测试的理解？" class="headerlink" title="对软件测试的理解？"></a>对软件测试的理解？</h3><ul><li>软件测试就是说要去根据客户的要求完善它。即要把这个软件还没有符合的或者是和客户要求不一样的，或者是客户要求还没有完全达到要求的部分找出来。</li><li>首先要锻炼自己软件测试能力，包括需求的分析能力，提取能力，逻辑化思想能力，即就是给你一个系统的时候，能够把整个业务流程很清晰的理出。</li><li>学习测试理论知识并与你锻炼的能力相结合。</li><li>想和做。想就是说你看到任何的系统都要有习惯性的思考；做就是把实际去做练习，然后提取经验。</li><li>总结测试用例，测试计划固然重要，但能力和思想一旦到位了，才能成为一名合格的软件测试工程师。</li></ul><h2 id="软件测试的分类"><a href="# 软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类 </h2><h3 id="按照测试技术划分"><a href="# 按照测试技术划分" class="headerlink" title="按照测试技术划分"></a> 按照测试技术划分</h3><ul><li><p>白盒测试</p><ul><li>通过对程序内部结构的分析、检测来寻找问题。检查是否所有的结构及逻辑都是正确的，检查软件内部动作是否按照设计说明的规定正常进行。—结构测试</li></ul></li><li><p>黑盒测试</p><ul><li>通过软件的外部表现来发现错误，是在程序界面处进行测试，只是检查是否按照需求规格说明书的规定正常实现。—功能测试</li></ul></li><li><p>灰盒测试</p><ul><li>介于白盒测试与黑盒测试之间的测试。</li></ul></li></ul><h3 id="按照是否让备测软件运行划分"><a href="# 按照是否让备测软件运行划分" class="headerlink" title="按照是否让备测软件运行划分"></a>按照是否让备测软件运行划分</h3><ul><li>静态测试</li><li>动态测试</li></ul><h3 id="按照开发阶段划分"><a href="# 按照开发阶段划分" class="headerlink" title="按照开发阶段划分"></a>按照开发阶段划分</h3><ul><li><p>单元测试</p><ul><li>模块测试，检查每个程序单元嫩否正确实现详细设计说明中的模块功能等。</li></ul></li><li><p>集成测试</p><ul><li>组装测试，将所有的程序模块进行有序、递增的测试，检验程序单元或部件的接口关系</li></ul></li><li><p>系统测试</p><ul><li>检查完整的程序系统能否和系统（包括硬件、外设和网络、系统软件、支持平台等）正确配置、连接，并满足用户需求。</li></ul></li><li><p>确认测试</p><ul><li>证实软件是否满足特定于其用途的需求，是否满足软件需求说明书的规定。</li></ul></li><li><p>验收测试</p><ul><li>按项目任务或合同，供需双方签订的验收依据文档进行的对整个系统的测试与评审，决定是否接受或拒收系统。</li></ul></li></ul><h3 id="按照测试实施组织划分"><a href="# 按照测试实施组织划分" class="headerlink" title="按照测试实施组织划分"></a>按照测试实施组织划分</h3><ul><li>开发方测试</li><li>用户测试</li><li>第三方测试</li></ul><h2 id="软件测试的原则"><a href="# 软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h2><ol><li>测试用例中一个必需部分是对预期输出或结果的定义；</li><li>程序员应当避免测试自己编写的程序；</li><li>编写软件的组织不应当测试自己编写的程序；</li><li>应该彻底检查每个测试的执行结果；</li><li>测试用例的编写不仅应当根据有效和预期的输入情况，也应当根据无效和未预料到的输入情况；</li><li>检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了不应该做的”；</li><li>应避免测试用例用后即弃，除非软件本身就是一个一次性的软件；</li><li>计划测试工作时不应默许假定不会发现错误；</li><li>程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比；</li><li>软件测试是一项极富创造性、极具智力挑战性的工作。</li></ol><h2 id="测试用例的设计"><a href="# 测试用例的设计" class="headerlink" title="测试用例的设计"></a>测试用例的设计 </h2><h3 id="测试用例的定义"><a href="# 测试用例的定义" class="headerlink" title="测试用例的定义"></a> 测试用例的定义</h3><ul><li>测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果。</li><li>测试用例是执行的最小实体。</li></ul><h3 id="特征"><a href="# 特征" class="headerlink" title="特征"></a>特征</h3><ul><li>最有可能抓住错误的；</li><li>不是重复的、多余的；</li><li>一组相似测试用例中最有效的；</li><li>既不是太简单，也不是太复杂。</li></ul><h3 id="设计测试用例的基本准则"><a href="# 设计测试用例的基本准则" class="headerlink" title="设计测试用例的基本准则"></a>设计测试用例的基本准则</h3><ul><li>测试用例的代表性、测试结果的可判定性、测试结果的可再现性。</li></ul><h2 id="黑盒测试"><a href="# 黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试 </h2><h3 id="等价类划分法"><a href="# 等价类划分法" class="headerlink" title="等价类划分法"></a> 等价类划分法</h3><ul><li><p>等价类划分法的设计方法</p><ul><li>是把所有可能的输入数据，即程序的输入域划分成若干部分（子集），然后从每一个子集中选取少量具有代表性的数据作为测试用例。</li><li>等价类是指某个输入域的子集合。在该子集合中各个输入数据对于揭露程序中错误都是等效的。并合理地假定：测试某等价类的代表值就等于对这一类其他值的测试。</li><li>有效等价类：对于程序的规格说明来说是合理的、有意义的输入数据构成的集合</li><li>无效等价类：对软件规格说明而言，是无意义的、不合理的输入数据所构成的集合</li><li>等价类对于测试有两个重要的意义：完备性、无冗余性</li></ul></li><li><p>等价类划分法的原则</p><ul><li><p>按照区间划分</p><ul><li>一个有效等价类和两个无效等价类。</li></ul></li><li><p>按照数值划分</p><ul><li>n 个有效等价类和一个无效等价类</li></ul></li><li><p>按照数值集合划分</p><ul><li>一个有效等价类和一个无效等价类</li></ul></li><li><p>按照限制条件或规则划分</p><ul><li>可确定一个有效等价类和若干个无效等价类</li></ul></li><li><p>细分等价类</p></li></ul></li><li><p>等价类划分法的步骤</p><ul><li><p>确定等价类</p></li><li><p>建立等价类表，列出所有划分出的等价类</p></li><li><p>从划分出的等价类中按以下的 3 个原则设计测试用例：</p><ul><li>为每一个等价类规定一个唯一的编号</li><li>设计一个新的测试用例，使其尽可能多的覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；</li><li>设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。  </li></ul></li></ul></li><li><p>确定等价类的方法</p><ul><li>先考虑输入数据的类型（合法型和非法型）；</li><li>再考虑数据范围（合法型中的合法区间和非法区间）；</li><li>最后考虑输出结果，逆向设定输入。</li></ul></li></ul><h3 id="边界值分析法"><a href="# 边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h3><ul><li><p>边界值分析法就是对输入或输出的边界值进行测试</p></li><li><p>特点</p><ul><li>具有很强的发现程序错误的能力；测试用例来自等价类的边界；</li></ul></li><li><p>基本原理</p><ul><li>故障往往发生在输入定义域和输出值域的边界上，而不是在其内部。</li></ul></li><li><p>方法</p><ul><li>首先应确定边界情况</li><li>选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据</li></ul></li><li><p>标准边界值：min、min+、nom、max-、max<br>健壮边界值：min、min+、nom、max-、max、min-、max+</p></li><li><p>例</p><ul><li>&lt;xnom,ymin&gt;，&lt;xnom,ymin+&gt;，&lt;xnom,ymax&gt;，&lt;xnom,ymax-&gt;，</li><li>&lt;xmin,ynom&gt;，&lt;xmin+,ynom&gt;，&lt;xmax,ynom&gt;，&lt;xmax-,ynom&gt;，</li><li>&lt;xnom,ynom&gt;</li></ul></li><li><p>对于一个含有 n 个变量的程序，只让其中一个变量取极值，让其余的变量取正常值，被保留的变量依次取 min、min+、nom、max-、max 值，对每个变量都重复进行。n 个变量的程序，边界值分析测试程序会产生 4n+1 个测试用例。</p></li></ul><h3 id="决策表法"><a href="# 决策表法" class="headerlink" title="决策表法"></a>决策表法</h3><ul><li><p>概述</p><ul><li>决策表法是黑盒测试方法中最为严格、最具有逻辑性的测试方法。</li></ul></li><li><p>什么时候使用？</p><ul><li>程序输入输出比较多，输入之间、输出之间相互制约的条件比较多时，可以清楚地表达它们之间的各种复杂关系。</li></ul></li><li><p>决策表通常由四部分组成</p><ul><li><p>条件桩</p><ul><li>列出问题的所有条件</li></ul></li><li><p>条件项</p><ul><li>针对条件桩给出的条件列出所有可能的取值</li></ul></li><li><p>动作桩</p><ul><li>给出问题规定的可能采取的操作</li></ul></li><li><p>动作项</p><ul><li>与条件项紧密相关，指出在条件项的各组取值情况下应采取的动作</li></ul></li><li><p>规则</p><ul><li>项中的每一列是一条规则，每一条规则是一组测试用例。</li></ul></li></ul></li><li><p>决策表的化简</p><ul><li>合并：如果一个条件项 (表中某列中的条件值) 和另外一个条件项所产生的动作是相同的, 且两个条件项对应的每一行的值只有一个是不同的, 则可以将其合并. 合并的项除了不同值变成”不关心”条目外, 其余不变</li><li>包含：如果两个条件项的动作是相同的，对任意条件 1 的值和条件 2 中对应的值：<br>– 如果条件 1 的值是 T(F), 则条件 2 中的值也是 T(F).<br>– 如果条件 1 的值是 -(不关心), 则条件 2 中的值是 T,F,-，<br>称条件 1 包含条件 2, 条件 2 可以撤去。</li><li>重复 A,B 就可以得到精简的决策表。</li></ul></li><li><p>构造决策表的步骤</p><ul><li>确定规则的个数；</li><li>列出所有的条件桩和动作桩；</li><li>填入输入项；</li><li>填入动作项, 得到初始的决策表；</li><li>对初始的决策表化简。</li></ul></li><li><p>决策表测试法的适用范围</p><ul><li>if-then-else 逻辑突出；</li><li>输入变量之间存在逻辑关系；</li><li>涉及输入变量子集的计算；</li><li>输入和输出之间存在因果关系。</li></ul></li></ul><h3 id="因果图方法"><a href="# 因果图方法" class="headerlink" title="因果图方法"></a>因果图方法</h3><ul><li><p>①概述</p><ul><li>如果输入之间有关系，测试时必须考虑输入条件的各种组合，考虑适合于描述对于多种条件的组合，相应产生多个动作的形式来设计测试用例，这就需要利用因果图。 因果图方法最终生成的就是判定表。适合于检查程序输入条件的各种组合情况。</li></ul></li><li><p>②因果图法的基本思想</p><ul><li>首先从程序规格说明书的描述中, 找出因 (输入条件) 和果(输出结果或者程序状态的改变), 然后通过因果图转换为判定表, 最后为判定表中的每一列设计一个测试用例。</li></ul></li><li><p>③基本符号</p><ul><li>通常在因果图中用 Ci 表示原因，用 Ei 表示结果，各结点表示状态，可取值“0”或“1”。“0”表示某状态不出现，“1”表示某状态出现。</li><li>恒等： c1 为 1, 则 e1 也为 1, 否则 e1 为 0.</li><li>非： 若 c1 是 1, 则 e1 为 0, 否则 e1 是 1.</li><li>或： 若 c1 或 c2 或 c3 是 1, 则 e1 是 1, 若三者都不为 1, 则 e1 为 0.</li><li>与： 若 c1 和 c2 都是 1, 则 e1 为 1, 否则若有其中一个不为 1, 则 e1 为 0.</li></ul></li><li><p>④约束</p><ul><li>实际问题中，输入状态之间可能存在某些依赖关系。</li><li>E 约束(互斥，排他，异)： a,b 最多有一个可能为 1, 不能同时为 1.</li><li>I 约束(包含，或)： a,b,c 中至少有一个必须为 1, 不能同时为 0.</li><li>O 约束(惟一)： a 和 b 必须有一个且仅有一个为 1</li><li>R 约束(要求)：a 是 1 时,b 必须是 1, 即 a 为 1 时,b 不能为 0</li><li>M 约束（屏蔽）：对输出条件的约束, 若结果 a 为 1, 则结果 b 必须为 0.</li></ul></li><li><p>⑤因果图生成测试用例的基本步骤</p><ul><li>找出原因和结果。</li><li>画出因果图。</li><li>增加约束。</li><li>把因果图转化为判定表，并化简。</li><li>把判定表的每一列拿出来作为依据，设计测试用例。</li></ul></li><li><p>⑥例题</p></li><li><p>⑦因果图法的优点</p><ul><li>考虑了多个输入之间的相互组合、相互制约关系；</li><li>能够帮助我们按一定步骤，高效率地选择测试用例，同时还能为我们指出，程序规格说明描述中存在着什么问题。</li></ul></li></ul><h2 id="白盒测试"><a href="# 白盒测试" class="headerlink" title="白盒测试"></a>白盒测试 </h2><h3 id="白盒测试概述"><a href="# 白盒测试概述" class="headerlink" title="白盒测试概述"></a> 白盒测试概述</h3><ul><li>白盒测试也称结构测试或逻辑驱动测试。</li></ul><h3 id="方法"><a href="# 方法" class="headerlink" title="方法"></a>方法</h3><ul><li>程序结构分析；</li><li>逻辑覆盖测试；</li><li>基本路径测试。</li></ul><h3 id="原则"><a href="# 原则" class="headerlink" title="原则"></a>原则</h3><ul><li>保证一个模块中所有独立路径至少被测试一次；</li><li>所有逻辑值均需测试真（True）和假（False）两种情况；</li><li>检查程序的内部数据结构，保证其结构的有效性；</li><li>在取值上、下边界，即可操作范围内运行所有循环</li></ul><h3 id="逻辑覆盖测试"><a href="# 逻辑覆盖测试" class="headerlink" title="逻辑覆盖测试"></a>逻辑覆盖测试 </h3><p> 主要是测试覆盖率，以程序内在逻辑结构为基础的测试。 6 种：语句覆盖 判断覆盖 条件覆盖 判定 - 条件覆盖 条件组合覆盖 路径测试</p><ul><li><p>语句覆盖：在测试时，首先设计若干个测试用例，然后运行被测程序，使程序中的每个可执行语句至少执行一次。</p><ul><li>判定：整体 控制。 包括：a、单一条件判定； b、符合条件覆盖</li><li>语句覆盖率：已执行的可执行语句占程序中可执行语句总数的百分比</li></ul></li><li><p>判定覆盖：设计足够多的测试用例，使程序中的每个判定至少都获得一次“真值”或“假值”。</p></li><li><p>条件覆盖: 构造一组测试用例，使得每一判定语句中每个逻辑条件的可能值至少满足一次。 满足条件覆盖的不一定满足判定覆盖，反之亦然。两者无直接关系。</p></li><li><p>判定 / 条件覆盖：设计足够的测试用例，使得判定中每个条件的所有可能 (真 / 假) 至少出现一次，并且每个判定本身的判定结果 (真 / 假) 也至少出现一次</p></li><li><p>条件组合覆盖（MCC）：设计足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。 满足组合条件覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定 / 条件覆盖。</p></li><li><p>修正条件判定覆盖(MCDC)：需要足够的测试用例来确定各个条件能够影响到包含的判定的结果，即要求满足两个条件。</p></li></ul><h2 id="静态测试"><a href="# 静态测试" class="headerlink" title="静态测试"></a>静态测试 </h2><h3 id="静态测试不实际运行软件，主要对软件的编程格式、结构等方面进行评估。可以有人工进行，也可借助软件工具自动进行。"><a href="# 静态测试不实际运行软件，主要对软件的编程格式、结构等方面进行评估。可以有人工进行，也可借助软件工具自动进行。" class="headerlink" title="静态测试不实际运行软件，主要对软件的编程格式、结构等方面进行评估。可以有人工进行，也可借助软件工具自动进行。"></a> 静态测试不实际运行软件，主要对软件的编程格式、结构等方面进行评估。可以有人工进行，也可借助软件工具自动进行。</h3><h3 id="静态测试的方法"><a href="# 静态测试的方法" class="headerlink" title="静态测试的方法"></a>静态测试的方法</h3><ul><li><p>代码检查：代码审查 代码走查 桌面检查 同行评分（略）</p></li><li><p>代码审查</p><ul><li>通常由 4 人组成，其中一人是协调人，一人是程序的编写者，其他人员通常是程序的设计人员以及测试专家。</li><li>优点和作用：错误列表、高效、会后修正、增加修改错误清单、较早发现错误。</li></ul></li><li><p>代码走查</p><ul><li>为测试员的人会带着一些书面的测试用例参加会议</li></ul></li><li><p>桌面检查</p><ul><li>完全没有约束</li><li>开发人员测试自己的程序</li><li>没有展示自己能力，缺乏良好的效应。（效果远远逊于代码审查和代码走查）</li></ul></li></ul><h3 id="静态结构分析"><a href="# 静态结构分析" class="headerlink" title="静态结构分析"></a>静态结构分析</h3><ul><li>主要是以图形的方式表现程序的内部结构。</li></ul><h3 id="代码质量度量"><a href="# 代码质量度量" class="headerlink" title="代码质量度量"></a>代码质量度量</h3><ul><li>功能性 可靠性 可用性 有效性 可维护性 轻便性</li></ul><h2 id="单元测试"><a href="# 单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="1．单元测试的定义"><a href="#1．单元测试的定义" class="headerlink" title="1．单元测试的定义"></a>1．单元测试的定义</h3><ul><li>单元测试又称模块测试，是最小单位的测试，其依据是详细设计描述，对模块内所有重要的控制路径设计测试用例，以便发现模块内部的错误。</li><li>单元测试多采用白盒测试技术</li></ul><h3 id="2．单元测试的对象"><a href="#2．单元测试的对象" class="headerlink" title="2．单元测试的对象"></a>2．单元测试的对象</h3><ul><li>结构化程序，单元测试的单元是指单个子程序、函数或过程</li><li>面向对象程序，单元测试的单元是指类或方法（通常为类）。</li></ul><h3 id="3．单元测试的目的"><a href="#3．单元测试的目的" class="headerlink" title="3．单元测试的目的"></a>3．单元测试的目的</h3><ul><li>将模块的功能与定义模块的功能规格说明或接口规格说明进行比较，揭示出模块与其规格说明之间存在的矛盾。</li></ul><h3 id="4．单元测试的人员"><a href="#4．单元测试的人员" class="headerlink" title="4．单元测试的人员"></a>4．单元测试的人员</h3><ul><li>开发人员</li></ul><h3 id="5．单元测试的针对的问题"><a href="#5．单元测试的针对的问题" class="headerlink" title="5．单元测试的针对的问题"></a>5．单元测试的针对的问题</h3><ul><li><p>模块接口</p><ul><li>检查进出程序单元的数据流是否正确。</li></ul></li><li><p>局部数据结构</p><ul><li>必须测试模块内部的数据能否保持完整性。</li></ul></li><li><p>边界条件测试</p><ul><li>主要检查临界数据是否正确处理。</li></ul></li><li><p>独立路径测试</p><ul><li>发现由于不正确的判定或不正常的控制流而产生的错误。</li></ul></li><li><p>出错处理</p><ul><li>要求能预见出错的条件，并设置适当的处理对象，保证其路径的正确性</li></ul></li></ul><h3 id="6．单元测试的流程"><a href="#6．单元测试的流程" class="headerlink" title="6．单元测试的流程"></a>6．单元测试的流程</h3><ul><li>计划单元测试→设计单元测试→执行单元测试→评估单元测试</li></ul><h3 id="7- 计划单元测试"><a href="#7- 计划单元测试" class="headerlink" title="7. 计划单元测试"></a>7. 计划单元测试</h3><ul><li>驱动模块(Drive)：用来模拟被测试模块的上一级模块，相当于被测模块的主程序。它接收数据，将相关数据传送给被测模块，启动被测模块，并打印出相应的结果。</li><li>桩模块(Stub)：用来模拟被测模块工作过程中所调用的模块。它们一般只进行很少的数据处理。</li></ul><h3 id="8．设计单元测试"><a href="#8．设计单元测试" class="headerlink" title="8．设计单元测试"></a>8．设计单元测试</h3><ul><li><p>需要的信息</p><ul><li>模块的规格说明：模块的输入和输出以及模块的功能。</li><li>模块的源代码。</li></ul></li><li><p>测试用例的设计方法</p><ul><li>模块测试总体上是面向白盒测试的（静态、动态）</li><li>后续测试针对较大的元素不易进行白盒测试。</li><li>后续测试着眼于发现其他类型的错误，不一定与程序逻辑结构有关。</li><li>使用一种或多种白盒测试方法分析模块的逻辑结构，然后使用黑盒测试方法对照模块的规格说明补充测试用例。</li></ul></li></ul><h3 id="9- 执行单元测试"><a href="#9- 执行单元测试" class="headerlink" title="9. 执行单元测试"></a>9. 执行单元测试</h3><ul><li>设置测试环境</li><li>将测试环境初始化</li><li>执行测试过程</li></ul><h3 id="10- 评估单元测试"><a href="#10- 评估单元测试" class="headerlink" title="10. 评估单元测试"></a>10. 评估单元测试</h3><ul><li>测试完备性评估</li><li>代码覆盖率评估 </li></ul><h2 id="集成测试"><a href="# 集成测试" class="headerlink" title="集成测试"></a>集成测试 </h2><h3 id="集成测试的定义"><a href="# 集成测试的定义" class="headerlink" title="集成测试的定义"></a> 集成测试的定义</h3><ul><li>集成测试又称组装测试，集成测试是在单元测试的基础上，将所有模块按照设计要求组装成子系统或系统进行的测试活动。</li></ul><h3 id="集成测试的目的"><a href="# 集成测试的目的" class="headerlink" title="集成测试的目的"></a>集成测试的目的</h3><ul><li>确保各单元组合在一起后能够按既定意图协作运行，并确保增量的行为正确，所测试的内容包括单元间的接口以及集成后的功能。</li></ul><h3 id="集成测试的层次"><a href="# 集成测试的层次" class="headerlink" title="集成测试的层次"></a>集成测试的层次</h3><ul><li>模块内集成测试</li><li>子系统内集成测试</li><li>子系统间集成测试</li></ul><h3 id="集成测试的流程"><a href="# 集成测试的流程" class="headerlink" title="集成测试的流程"></a>集成测试的流程 </h3><h3 id="集成测试的方法"><a href="# 集成测试的方法" class="headerlink" title="集成测试的方法"></a> 集成测试的方法</h3><ul><li>静态测试：只要指对概要设计的测试。</li><li>动态测试：以黑盒测试为主，需要了解内部细节时结合白盒测试</li></ul><h3 id="集成测试策略"><a href="# 集成测试策略" class="headerlink" title="集成测试策略"></a>集成测试策略</h3><ul><li><p>非增量式集成</p><ul><li><p>对所有模块进行个别的单元测试后，按照程序结构图将各模块连接起来，把连接后的程序当作一个整体进行测试。</p></li><li><p>关键模块的特征</p><ul><li> 满足某些软件需求；</li><li>在程序的模块结构中位于较高的层次（高层控制模块）；</li><li>较复杂、较易发生错误；</li><li>有明确定义的性能要求。</li></ul></li></ul></li><li><p>增量式集成</p><ul><li><p>逐次将未曾集成测试的模块和已经集成测试的模块（或子系统）结合成程序包，再将这些模块集成为较大系统，在集成的过程中边连接边测试，以发现连接过程中产生的问题。</p></li><li><p>方法</p><ul><li>自顶向下增量式测试：深度优先、广度优先</li><li>自底向上增量式测试</li><li>混合增量式测试</li></ul></li></ul></li></ul><h3 id="不同集成测试方法的比较"><a href="# 不同集成测试方法的比较" class="headerlink" title="不同集成测试方法的比较"></a>不同集成测试方法的比较 </h3><h2 id="系统测试"><a href="# 系统测试" class="headerlink" title="系统测试"></a> 系统测试 </h2><h3 id="系统测试的目的"><a href="# 系统测试的目的" class="headerlink" title="系统测试的目的"></a> 系统测试的目的</h3><ul><li>将系统或程序与其初始目标进行比较，这意味着系统测试并不局限于系统，系统测试是一个试图说明程序作为一个整体是如何不满足其目标的过程。如果产品没有一组书面的、可度量的目标，系统测试也无法进行。</li></ul><h3 id="系统测试的类型"><a href="# 系统测试的类型" class="headerlink" title="系统测试的类型"></a>系统测试的类型</h3><ul><li><p>（1）能力测试</p><ul><li>判断目标文档提及的每一项能力（以区别功能测试中的‘功能’）是否都确实已经实现。</li><li>通常是通过人工检查目标文档中定义了“要做什么”。</li></ul></li><li><p>（2）容量测试</p><ul><li>是程序经受大容量数据的检验，目的是证明程序不能处理目标文档中规定的数据容量。</li><li>容量测试需要大量的资源，不可进行过多。</li><li>如何使操作系统的作业队列达到饱和容量。</li></ul></li><li><p>（3）强度测试</p><ul><li>使程序承受高负载或强度的检验。所谓高强度是指在很短的时间间隔内达到的数据或操作的数量峰值。（要与容量测试相区分）</li><li>强度测试涉及时间因素，适用于在可变负载下运行的程序以及交互式程序、实时程序和过程控制程序。基于 Web 的应用程序也是最常接受强度测试的软件之一。</li><li>如，1. 在很短的时间内是操作系统的作业队列达到峰值；2.web 应用程序要处理一定容量的并发用户。</li><li>注：强度测试时对强度的界定很重要。 </li></ul></li><li><p>（4）易用性测试</p><ul><li>每个用户界面是否都根据用户的智力、教育程度和环境要求进行了调整？</li><li>程序的输出是否有意义、不模糊且无计算机杂乱信息？</li><li>错误诊断信息是否直接，非计算机专业用户是否能够理解（这要求对错误进行精确的预测和详细的分类）？</li><li>整体的用户界面是否在语法、惯例、语义、格式、风格和缩写等方面展现出了相当程度的完整性、一致性和同一性？</li><li>系统是否包含过多或不太可能用到的选项？</li><li>对于所有输入，系统是否返回了即时确认信息？</li><li>程序是否易于使用？如区分大小写的要求用户是否清楚，不同层次菜单之间的浏览是否容易等。</li></ul></li><li><p>（5）安全性测试</p><ul><li>设计测试用例来突破程序安全检查。例如，可以设计测试用例来规避操作系统的内存保护机制、破坏数据库管理系统的数据安全机制等。</li><li>常用的测试用例设计方法是研究类似系统中已知的安全问题，然后生成测试用例，暴露被测系统中的类似问题</li><li>基于 Web 的应用程序常常比绝大多数程序所需的安全测试级别更高，对于电子商务网站尤其如此。</li></ul></li><li><p>（6）性能测试</p><ul><li>很多软件都有特定的性能或效率目标，这些特性描述为在特定负载和配置环境下程序的响应时间和吞吐率。应设计测试用例来说明程序不能满足其性能目标。</li></ul></li><li><p>（7）存储测试</p><ul><li>软件偶尔会有存储目标，例如描述程序使用的内存和辅存的容量以及临时文件或移出文件的大小。应设计测试用例来证明这些存储目标没有得到满足。</li></ul></li><li><p>（8）配置测试</p><ul><li>很多软件都支持多种硬件配置，可以运行在多种操作系统下，使用多种 web 浏览器。通常可能的配置数量非常之大，以至于无法全面测试，但应该尽可能测试各种配置。</li></ul></li><li><p>（9）兼容性 / 配置 / 转换测试</p><ul><li>很多软件不是全新的，而是为了替换某些已有的系统。这样的软件往往涉及与已有系统的兼容以及从已有系统的转换过程，如升级数据库管理系统。</li></ul></li><li><p>（10）安装测试</p><ul><li>有些软件的安装过程非常复杂，测试安装过程是系统测试的一个重要部分。</li></ul></li><li><p>（11）可靠性测试</p><ul><li>所有测试都是为了提高软件的可靠性，但如果软件的目标中包含了对可靠性的特别描述，就必须设计专门的可靠性测试用例。</li></ul></li><li><p>（12）适用性测试</p><ul><li>对于软件的适用性和可维护性目标也必须测试。</li></ul></li><li><p>（13）可恢复性测试</p><ul><li>诸如 OS、DBMS 等软件通常都有可恢复性目标，说明系统如何从硬件失败和数据错误中恢复过来。系统测试的一个目标是证明这些恢复机制不能正确发挥作用。</li><li>可以故意将程序错误植入个系统中，判断系统是否可以从中恢复。</li><li>这些系统的设计目标之一是平均恢复时间（MTTR）最小，测试目标之一就是证明系统不能满足 MTTR 的要求。</li></ul></li><li><p>（14）文档测试</p><ul><li>系统测试也需要检查用户文档的正确性和清晰性。</li></ul></li><li><p>（15）过程测试</p><ul><li>很多软件系统不是完全自动化的，其中包括了很多人员操作过程。在系统测试中，必须对所有已规定的人工过程，如系统操作员、最终用户、数据库管理员的操作过程进行测试。</li></ul></li></ul><h2 id="验收测试"><a href="# 验收测试" class="headerlink" title="验收测试"></a>验收测试 </h2><h3 id="是将程序与其最初的需求及最终用户当前的需要进行比较的过程"><a href="# 是将程序与其最初的需求及最终用户当前的需要进行比较的过程" class="headerlink" title="是将程序与其最初的需求及最终用户当前的需要进行比较的过程"></a> 是将程序与其最初的需求及最终用户当前的需要进行比较的过程 </h3><h3 id="通常是由程序的客户或最终用户来进行，一般不认为是软件开发机构的职责"><a href="# 通常是由程序的客户或最终用户来进行，一般不认为是软件开发机构的职责" class="headerlink" title="通常是由程序的客户或最终用户来进行，一般不认为是软件开发机构的职责"></a> 通常是由程序的客户或最终用户来进行，一般不认为是软件开发机构的职责 </h3><h3 id="最好的方法是设计测试用例，尽力证明程序没有满足合同要求；假如这些测试用例都通过了，就可以接受该程序。"><a href="# 最好的方法是设计测试用例，尽力证明程序没有满足合同要求；假如这些测试用例都通过了，就可以接受该程序。" class="headerlink" title="最好的方法是设计测试用例，尽力证明程序没有满足合同要求；假如这些测试用例都通过了，就可以接受该程序。"></a> 最好的方法是设计测试用例，尽力证明程序没有满足合同要求；假如这些测试用例都通过了，就可以接受该程序。</h3><h2 id="补充"><a href="# 补充" class="headerlink" title="补充"></a>补充 </h2><h3 id="根据软件生命周期中的定义，可以把自动化测试工具分为 3 大类："><a href="# 根据软件生命周期中的定义，可以把自动化测试工具分为 3 大类：" class="headerlink" title="根据软件生命周期中的定义，可以把自动化测试工具分为 3 大类："></a> 根据软件生命周期中的定义，可以把自动化测试工具分为 3 大类：</h3><ul><li>白盒测试工具</li><li>黑盒测试工具</li><li>测试管理工具</li></ul><h3 id="白盒测试可分为哪两大类"><a href="# 白盒测试可分为哪两大类" class="headerlink" title="白盒测试可分为哪两大类"></a>白盒测试可分为哪两大类</h3><ul><li>静态测试</li><li>动态测试</li></ul><h3 id="软件是包括 -、-、- 的完整集合"><a href="# 软件是包括 -、-、- 的完整集合" class="headerlink" title="软件是包括_、_、_的完整集合"></a>软件是包括_、_、_的完整集合</h3><ul><li>程序</li><li>数据</li><li>相关文档</li></ul><h3 id="单元测试是以 - 说明书为指导，测试源程序代码"><a href="# 单元测试是以 - 说明书为指导，测试源程序代码" class="headerlink" title="单元测试是以_说明书为指导，测试源程序代码"></a>单元测试是以_说明书为指导，测试源程序代码</h3><ul><li>详细设计</li></ul><h3 id="集成测试以 - 说明书为指导，测试软件结构"><a href="# 集成测试以 - 说明书为指导，测试软件结构" class="headerlink" title="集成测试以_说明书为指导，测试软件结构"></a>集成测试以_说明书为指导，测试软件结构</h3><ul><li>概要设计</li></ul><h3 id="确认测试以 - 说明书为指导"><a href="# 确认测试以 - 说明书为指导" class="headerlink" title="确认测试以_说明书为指导"></a>确认测试以_说明书为指导</h3><ul><li>需求分析</li></ul><h3 id="软件开发的基本过程"><a href="# 软件开发的基本过程" class="headerlink" title="软件开发的基本过程"></a>软件开发的基本过程</h3><ul><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码</li><li>测试</li><li>维护</li></ul><h3 id="集成测试把模块组成成系统的测试方式：和"><a href="# 集成测试把模块组成成系统的测试方式：和" class="headerlink" title="集成测试把模块组成成系统的测试方式：和"></a>集成测试把模块组成成系统的测试方式：<em>和</em></h3><ul><li>一次性集成测试</li><li>增量式集成测试</li></ul><h3 id="黑盒测试有两种基本方法"><a href="# 黑盒测试有两种基本方法" class="headerlink" title="黑盒测试有两种基本方法"></a>黑盒测试有两种基本方法</h3><ul><li>通过测试</li><li>失败测试</li></ul><h3 id="Junit 中左右的 Assert 方法全部放在 - 类，用于对比 - 和实际值是否相同"><a href="#Junit 中左右的 Assert 方法全部放在 - 类，用于对比 - 和实际值是否相同" class="headerlink" title="Junit 中左右的 Assert 方法全部放在_类，用于对比_和实际值是否相同"></a>Junit 中左右的 Assert 方法全部放在_类，用于对比_和实际值是否相同</h3><ul><li>Assert</li><li>期望值</li></ul><h3 id="软件测试的目的是"><a href="# 软件测试的目的是" class="headerlink" title="软件测试的目的是"></a>软件测试的目的是</h3><p>A) 证明软件的正确性<br>B) 找出软件系统中存在的所有错误<br>C) 证明软件系统中存在错误<br>D) 尽可能多地发现软件系统中的错误</p><ul><li>D</li><li>[解析] 软件测试是为了发现程序中的错误而执行程序的过程，所以软件测试的目的是尽可能多地发现软件系统中的错误，而不是证明程序或软件的正确性。一个成功的测试应该是发现了至今为止尚未发现的错误。</li></ul><h3 id="按照测试组织划分，软件测试可分为：开发方测试、第三方测试和"><a href="# 按照测试组织划分，软件测试可分为：开发方测试、第三方测试和" class="headerlink" title="按照测试组织划分，软件测试可分为：开发方测试、第三方测试和_"></a>按照测试组织划分，软件测试可分为：开发方测试、第三方测试和_</h3><ul><li>用户测试</li></ul><h3 id="计算环路复杂度的方法有哪三种"><a href="# 计算环路复杂度的方法有哪三种" class="headerlink" title="计算环路复杂度的方法有哪三种"></a>计算环路复杂度的方法有哪三种</h3><ul><li>V(G) = 判定节点数 + 1</li><li>V(G) = E - N + 2</li><li>V(G) = 区域数 + 1</li></ul><p><em>XMind - Trial Version</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算与大数据概论</title>
      <link href="notes/yun-ji-suan-yu-da-shu-ju-gai-lun/"/>
      <url>notes/yun-ji-suan-yu-da-shu-ju-gai-lun/</url>
      
        <content type="html"><![CDATA[<h2 id="云计算与大数据概述"><a href="# 云计算与大数据概述" class="headerlink" title="云计算与大数据概述"></a>云计算与大数据概述 </h2><h3 id="云计算的概念"><a href="# 云计算的概念" class="headerlink" title="云计算的概念"></a> 云计算的概念</h3><ul><li>云计算（Cloud Computing）由分布式计算（Distributed Computing）、并行处理（Parallel Computing）和网格计算（Grid Computing）发展而来。</li><li>狭义 <br> 厂商通过分布式计算和虚拟化技术搭建数据中心或超级计算机，以免费或按需租用的方式向技术开发者或企业客户提供数据存储、分析以及科学计算等服务。</li><li>广义 <br> 厂商通过建立网络服务器集群，向各种不同类型的客户提供在线软件使用、硬件租借、数据存储、计算分析等不同类型的服务。</li></ul><h3 id="云计算的特点"><a href="# 云计算的特点" class="headerlink" title="云计算的特点"></a>云计算的特点</h3><ul><li>超大规模</li><li>虚拟化</li><li>高可靠性</li><li>通用性</li><li>高可扩展性</li><li>按需服务</li><li>极其廉价</li></ul><h3 id="大数据的特点"><a href="# 大数据的特点" class="headerlink" title="大数据的特点"></a>大数据的特点</h3><ul><li>数据量大</li><li>多样性</li><li>价值密度低</li><li>时效性要求高</li><li>真实性</li></ul><h3 id="云计算的分类"><a href="# 云计算的分类" class="headerlink" title="云计算的分类"></a>云计算的分类</h3><ul><li><p>所有权来分</p><ul><li>私有云</li><li>共有云</li><li>混合云</li></ul></li><li><p>服务类型来分</p><ul><li><p>IaaS</p><ul><li>EC2、Azure</li></ul></li><li><p>PaaS</p><ul><li>Google App Engine、Hadoop</li></ul></li><li><p>SaaS</p><ul><li>Google Doc、Google Apps、Zoho Office</li></ul></li><li><p>DaaS</p></li></ul></li></ul><h3 id="主流云计算和大数据供应商"><a href="# 主流云计算和大数据供应商" class="headerlink" title="主流云计算和大数据供应商"></a>主流云计算和大数据供应商</h3><ul><li><p>Amazon 云计算</p><ul><li>弹性计算云、简单存储服务、弹性块存储服务、RDB 服务、NoSQL DB 服务，还提供与网络、数据分析、机器学习、物联网、移动服务开发、云管理、云安全等有关的服务</li></ul></li><li><p>IBM 云计算</p></li><li><p>Google 云计算</p><ul><li>GAE</li></ul></li><li><p>微软云计算</p><ul><li>Azure、SkyDrive、Office 365</li></ul></li><li><p>阿里巴巴云服务</p><ul><li><p>阿里云基于电商的技术特长包括并发事务的处理、都事务状态的控制、对交易安全的控制等。</p></li><li><p>飞天开放平台（Apsara）</p><ul><li>负责管理 Linux 集群的物理资源，控制分布式程序的运行，并隐藏下层故障恢复和数据冗余等细节，从而将数以千计甚至万计的服务器联成一台超级计算机。</li></ul></li><li><p>云计算基础服务</p><ul><li>ECS、CDN、RDS、OSS、SLB</li></ul></li><li><p>域名与网站服务</p></li><li><p>安全服务</p><ul><li>云盾</li></ul></li><li><p>大数据服务</p><ul><li>大数据可视化和计算服务</li></ul></li></ul></li><li><p>百度开放云</p><ul><li>云服务器 BCC、BLB、BOS、云磁盘 CDS、CDN、RDS、简单缓存服务 SCS</li></ul></li><li><p>腾讯云平台</p><ul><li><p>计算和网络服务</p><ul><li>云服务器、弹性 Web 引擎 CEE、负载均衡服务</li></ul></li><li><p>存储于 CDN 服务</p><ul><li>CDB、NoSQL 高速存储、对象存储服务 COS、CDN</li></ul></li><li><p>监控与安全服务</p><ul><li>云监控、云安全</li></ul></li><li><p>大数据服务</p><ul><li>大数据处理 TOD、腾讯云分析</li></ul></li></ul></li></ul><h3 id="云计算与大数据的关系"><a href="# 云计算与大数据的关系" class="headerlink" title="云计算与大数据的关系"></a>云计算与大数据的关系</h3><ul><li><p>从技术上</p><ul><li><p>大数据根植于云计算，云计算关键技术中的海量数据存储和管理技术以及 MapReduce 并行编程模型都是大数据技术的基础。</p></li><li><p>云计算技术</p><ul><li>虚拟化技术</li><li>云计算平台管理技术</li><li>MapReduce 编程模型</li><li>海量数据存储技术</li><li>海量数据管理技术</li></ul></li></ul></li><li><p>从整体上</p><ul><li>大数据着眼于“数据”，关注实际业务，包括数据采集、分析与挖掘技术，看重信息沉淀，即数据存储能力；</li><li>云计算着眼于“计算”，关注 IT 解决方案，提供 IT 基础架构，看重的是计算能力，即数据处理能力。</li><li>大数据技术能处理各种类型的海量数据，包括微博、图片、文章、电子邮箱、文档、音频、视频以及其他类型的数据；<br>它对数据的处理速度非常快，几乎实时；<br>它具有普及性，因为它使用的都是最普遍的第成本硬件。</li><li>云计算技术则将计算任务分布在大量计算机构成的资源池上，是用户能够按需获取计算处理能力、存储空间和其他服务实现了廉价获取超能计算和存储的能力。<br>这种“低成本硬件 + 低成本软件 + 低成本运维”模式更加经济和实用，能够很好地支持大数据存储和处理需求，使得从大数据中获得有价值的信息成为可能。</li></ul></li><li><p>云计算和大数据技术的异同</p><table><thead><tr><th align="left"></th><th align="left">大数据</th><th align="left">云计算</th></tr></thead><tbody><tr><td align="left">总体关系</td><td align="left">为云计算提供了有价值的用武之地</td><td align="left">为大数据提供了有力的工具和途径</td></tr><tr><td align="left">相同点</td><td align="left">为数据存储和处理服务；</td><td align="left">需要大量的存储和计算资源（共同技术）</td></tr><tr><td align="left">背景</td><td align="left">现有数据处理不能胜任社交网络和物联网产生的大量异构数据，但它们存在很大价值</td><td align="left">基于互联网的相关服务日益丰富和频繁</td></tr><tr><td align="left">目的</td><td align="left">充分挖掘海量数据中的信息</td><td align="left">通过互联网更好地调用、扩展和管理计算及存储方面地资源和能力</td></tr><tr><td align="left">对象</td><td align="left">数据</td><td align="left">IT 资源、能力和应用</td></tr><tr><td align="left">推动力量</td><td align="left">从事数据存储与处理地软件厂商、拥有大量数据的企业</td><td align="left">生产计算及存储设备的厂商、拥有计算及存储资源的企业</td></tr><tr><td align="left">价值</td><td align="left">发现数据中的价值</td><td align="left">节省 IT 部署成本</td></tr></tbody></table></li><li><p>大数据利用云计算的强大计算能力，可以更加迅速地处理海量数据的丰富信息，为用户提供更加方便的服务；<br>通过大数据的业务需求，也为云计算的落地找到更多、更好的实际应用。<br>云计算和大数据技术的联合改变了计算机的运行方式，也正在改变着各行各业的商业模式。</p></li></ul><h2 id="云计算技术"><a href="# 云计算技术" class="headerlink" title="云计算技术"></a>云计算技术 </h2><h3 id="虚拟化技术"><a href="# 虚拟化技术" class="headerlink" title="虚拟化技术"></a> 虚拟化技术</h3><ul><li><p>虚拟化技术的定义</p><ul><li><p>计算机虚拟化是一个广义的术语，简单来说，是指计算机相关模块在虚拟的基础上而不是真实独立的物理硬件基础上运行，这种把有限的固定资源根据不同的需求进行重新规划以达到最大利用率，从而实现简化管理、优化资源等目的的思路，就叫做虚拟化技术。</p></li><li><p>虚拟化包含了以下三层含义</p><ul><li>虚拟化的对象是各种各样的资源</li><li>经过虚拟化后的逻辑资源对用户隐藏了不必要的细节</li><li>用户可以在虚拟环境中实现其在真实环境中的部分或者全部功能</li></ul></li></ul></li><li><p>虚拟化技术的优势</p><ul><li>可以大大提高资源的利用率</li><li>可以提供相互隔离的安全、高效的应用执行环境</li><li>虚拟化系统能够方便地管理和升级资源</li></ul></li><li><p>虚拟化的技术实现</p><ul><li><p>基础设施虚拟化</p><ul><li><p>硬件虚拟化</p><ul><li>CPU、内存、硬盘、声卡、显卡、光驱</li></ul></li><li><p>网络虚拟化</p><ul><li><p>局域网虚拟化</p><ul><li>VLAN</li></ul></li><li><p>广域网虚拟化</p><ul><li>VPN</li></ul></li></ul></li><li><p>存储虚拟化</p><ul><li><p>基于存储设备</p><ul><li>RAID</li></ul></li><li><p>基于网络</p><ul><li>存储局域网（SAN）、网络存储（NAS）</li></ul></li></ul></li><li><p>文件虚拟化</p></li></ul></li><li><p>系统虚拟化</p><ul><li>PC 上</li><li>服务器上</li><li>桌面虚拟化</li></ul></li><li><p>软件虚拟化</p><ul><li>应用虚拟化</li><li>高级语言虚拟化技术</li></ul></li></ul></li><li><p>虚拟化的应用领域</p><ul><li><p>应用程序虚拟化</p><ul><li>应用虚拟化是 SaaS 的基础</li></ul></li><li><p>服务器虚拟化</p><ul><li><p>服务器虚拟化是 IaaS 的基础</p></li><li><p>服务器虚拟化架构<br>Guest OS、VMM（Hypervisor）</p><ul><li><p>寄生架构（Hosted）</p><ul><li>Virtual Box</li></ul></li><li><p>裸金属架构（Bare-metal）</p><ul><li>KVM、Xen、VMware ESX</li></ul></li></ul></li><li><p>服务器虚拟化实现原理</p><ul><li>CPU 虚拟化</li><li>内存虚拟化</li><li>设备与 I/O 虚拟化</li></ul></li></ul></li><li><p>桌面虚拟化</p></li><li><p>网络虚拟化</p><ul><li>网络虚拟化也是 IaaS 的基础之一</li></ul></li><li><p>存储虚拟化</p></li></ul></li></ul><h3 id="分布式技术"><a href="# 分布式技术" class="headerlink" title="分布式技术"></a>分布式技术</h3><ul><li><p>分布式系统是建立在网络之上的支持分布式处理的软件系统，同样具有软件的内聚性和透明性。</p></li><li><p>分布式文件系统<br>Lustre、GFS、HDFS、FastDFS、MogileFS</p></li><li><p>分布式数据库系统<br>BigTable、HBase、CouchDB、MongoDB</p></li><li><p>分布式计算</p><ul><li>实时性要求不高</li><li>允许存在计算错误</li></ul></li></ul><h2 id="云计算平台"><a href="# 云计算平台" class="headerlink" title="云计算平台"></a>云计算平台</h2><h3 id="Google 云平台"><a href="#Google 云平台" class="headerlink" title="Google 云平台"></a>Google 云平台</h3><ul><li><p>体系结构</p><ul><li><p>网络系统</p><ul><li>内部网络</li><li>外部网络</li></ul></li><li><p>硬件系统</p><ul><li>单个服务器</li><li>整合多个服务器的机架</li><li>连接各服务器机架的数据中心（IDC）</li></ul></li><li><p>软件系统</p><ul><li><p>单机操作系统</p></li><li><p>Google 云计算底层软件系统</p><ul><li>GFS</li><li>并行计算模型 MapReduce</li><li>并行数据库 BigTable</li><li>并行锁服务 Chubby</li><li>云计算消息队列 GWQ</li></ul></li></ul></li><li><p>Google 应用</p><ul><li>Google 内部软件开发工具</li><li>GAE</li><li>SaaS 服务，Google Search、Google Gmail、Google Map、Google Earth</li></ul></li></ul></li><li><p>核心技术</p><ul><li>GFS</li><li>MapReduce</li><li>Chubby</li><li>BigTable</li><li>Megastore</li><li>Dapper</li></ul></li></ul><h3 id="Amazon 云平台"><a href="#Amazon 云平台" class="headerlink" title="Amazon 云平台"></a>Amazon 云平台</h3><ul><li><p>存储架构 Dynamo</p></li><li><p>弹性计算云 EC2</p><ul><li>SSH</li><li>Amazon 机器镜像 AMI</li><li>弹性块存储 EBS</li><li>EC2 通讯机制</li><li>ELB</li><li>监控服务 CloudWatch</li></ul></li><li><p>简单存储服务 S3</p></li><li><p>简单队列服务 SQS</p></li><li><p>其他 AWS</p><ul><li>RDS</li><li>Amazon CloudFront</li><li>快速应用部署 Elastic Beanstalk 和服务模板 CloudFormation</li></ul></li></ul><h3 id="微软 Windows-Azure 平台"><a href="# 微软 Windows-Azure 平台" class="headerlink" title="微软 Windows Azure 平台"></a>微软 Windows Azure 平台</h3><ul><li><p>计算服务</p><ul><li>虚拟机</li><li>云服务 Cloud Services</li><li>批处理</li></ul></li><li><p>数据存储服务</p><ul><li>文件存储服务</li><li>RDB 存储服务</li><li>DocumentDB</li></ul></li><li><p>其他服务</p><ul><li>通知中心服务</li><li>Azure Redis 缓存服务</li><li>物联网相关服务</li></ul></li></ul><h3 id="阿里云服务平台"><a href="# 阿里云服务平台" class="headerlink" title="阿里云服务平台"></a>阿里云服务平台</h3><ul><li><p>计算服务</p><ul><li>ECS</li><li>批量计算 BatchCompute</li><li>专有网络 VPC</li><li>弹性伸缩 AS</li></ul></li><li><p>数据存储服务</p><ul><li>文件存储 NAS</li><li>云数据库 RDS</li><li>云数据库 Redis 版</li></ul></li><li><p>数据分析服务</p><ul><li>阿里云机器学习平台</li><li>推荐引擎</li><li>DataV 数据可视化服务</li></ul></li><li><p>其他服务</p><ul><li>CDN</li><li>域名、移动推送、语言、短信、云监控等</li></ul></li></ul><h3 id="百度开发者云平台"><a href="# 百度开发者云平台" class="headerlink" title="百度开发者云平台"></a>百度开发者云平台</h3><ul><li><p>计算服务</p><ul><li>百度物理服务器 BBC</li><li>百度应用引擎 BAE</li></ul></li><li><p>数据存储服务</p><ul><li>百度对象存储 BOS</li><li>RDS</li><li>简单缓存服务 SCS</li></ul></li><li><p>数据分析服务</p><ul><li>BMR</li><li>百度深度学习平台 Paddle</li></ul></li><li><p>其他服务</p><ul><li>人脸识别 BFR</li><li>光符识别 OCR</li><li>文档服务 DS</li><li>物接入</li></ul></li></ul><h3 id="腾讯云服务平台"><a href="# 腾讯云服务平台" class="headerlink" title="腾讯云服务平台"></a>腾讯云服务平台</h3><ul><li><p>计算服务</p><ul><li>云服务器 CVM</li><li>物理服务器 CPM</li><li>弹性伸缩 AS</li><li>消息服务 CMQ</li></ul></li><li><p>数据存储服务</p><ul><li>对象存储服务 COS</li><li>云数据库 CDB</li><li>云存储 Redis（CRS）</li><li>分布式云数据库 DDB</li></ul></li><li><p>数据分析</p><ul><li>腾讯机智机器学习 TML</li><li>腾讯大数据处理套件 TBDS</li><li>用户洞察分析 CP</li></ul></li><li><p>其他服务</p><ul><li>点播 VOD</li><li>直播 LVB</li></ul></li></ul><h2 id="大数据技术"><a href="# 大数据技术" class="headerlink" title="大数据技术"></a>大数据技术 </h2><h3 id="大数据应用系统架构"><a href="# 大数据应用系统架构" class="headerlink" title="大数据应用系统架构"></a> 大数据应用系统架构</h3><ul><li><p>大数据应用系统架构原则</p><ul><li><p>大数据给传统应用架构带来了巨大的挑战</p><ul><li>数据容量方面</li><li>数据分析方面</li><li>企业级应用标准方面</li></ul></li><li><p>进行大数据应用架构的总体设计时，需要遵循以下原则</p><ul><li>满足“5V”要求，具备大容量数据的加载、处理和分析的能力；具备各种类型数据的加载、处理和分析能力；满足大数据处理速度的要求。</li><li>满足企业级应用的要求，具备高可扩展性、高可用性、高安全性、高开放性和易用性。</li><li>满足分析原始格式数据的要求，具备整合分析复杂的原始格式数据的能力。</li></ul></li></ul></li><li><p>Apache 大数据应用系统架构模型</p><ul><li><p>物理服务器 -servers</p></li><li><p>OS 和 Hypervisor</p></li><li><p>数据存储层 -Storage Framework</p><ul><li>HDFS</li></ul></li><li><p>数据处理层 -Processing Framework</p><ul><li>MapReduce 处理模型</li></ul></li><li><p>Network</p></li><li><p>访问层 -Access Framework</p><ul><li>Pig<br>基于 Hadoop 的大规模数据分析工具，提供类 SQL 的查询语言 Pig Latin。</li><li>Hive<br>建立在 Hadoop 上的数据仓库基础架构。提供了简单的类 SQL 查询语言 HQL。用于静态批处理。</li><li>Sqoop<br>将 Hadoop 和 RDB 中的数据相互转移的工具。</li></ul></li><li><p>完成数据高层次处理 -Orchestration Framework</p><ul><li>HBase<br>具有高可靠性、高性能、面向列、可伸缩、可在廉价 PC 服务器上搭建大规模结构化存储集群等特点。能将零散的、非结构化文件数据结构化，从而进行一些高层次操作。</li><li>Avro<br>基于二进制数据高性能传输的中间件、数据序列化系统。</li><li>Flume<br>Cloudera 公司提供的一个对海量日志进行采集、聚合和传输的分布式系统。</li><li>ZooKeeper<br>Google 的 Chubby 的一个开源实现，是一个针对大型分布式系统的可靠协调系统，其功能包括配置维护、名字服务、分布式同步、组服务等。ZooKeeper 的目标是封装好复杂且易出错的关键服务，将简单易用的接口与性能高效、高能稳定的系统提供给用户。</li></ul></li><li><p>企业数据仓库和商业智能 -EDW 和 BI</p><ul><li>EDW 致力于研究和解决从数据库中获取信息的问题，是一个以 RDB 为依托，以数据仓库理论为指导，以 OWB（Oracle Warehouse Builder）、ODI（Oracle Data Integrator）、IPC（IndormaticPowerCenter）等抽取、转换、装载（Extract-Transform-Load，ETL）工具进行数据集成、整合、清洗与加载转换，以前端工具进行前端报表展现，一反复迭代验证为生命周期的综合处理过程。</li><li>BI 同样是一套辅助决策的智能系统，其核心是帮助企业利用好数据，让决策管理者能够随时随地地获取关键信息，基于数字作出决策，最终提高决策水平。</li></ul></li></ul></li><li><p>企业大数据应用系统架构模型</p><ul><li><p>数据源</p><ul><li>结构化数据</li><li>非结构化数据</li><li>半结构化数据</li><li>流数据</li></ul></li><li><p>存储层</p><ul><li>DBMS</li><li>NoSQL</li><li>HDFS</li></ul></li><li><p>计算层</p><ul><li>离线处理</li><li>流计算框架</li><li>内存计算</li></ul></li><li><p>分析层</p><ul><li>数据挖掘</li><li>分析和查询工具</li><li>可视化</li></ul></li><li><p>应用层</p><ul><li>应用软件</li><li>商业智能</li></ul></li><li><p>服务管理和系统安全</p></li></ul></li></ul><h3 id="大数据关键技术"><a href="# 大数据关键技术" class="headerlink" title="大数据关键技术"></a>大数据关键技术</h3><ul><li><p>数据收集技术</p><ul><li><p>设备数据收集</p><ul><li>Splunk</li><li>Sqoop</li><li>Flume</li></ul></li><li><p>Web 数据爬取</p><ul><li>Heriteix</li><li>Nutch</li></ul></li></ul></li><li><p>数据预处理技术</p><ul><li><p>数据清洗技术</p><ul><li>数据不一致检测技术</li><li>脏数据识别技术</li><li>数据过滤技术</li><li>数据修正技术</li><li>数据噪声的识别与平滑技术</li></ul></li><li><p>数据集成技术</p><ul><li>把来自多个数据源的数据进行集成，缩短数据之间的物理距离，形成一个集中统一的（同构 / 异构）数据库、数据立方体、数据宽表或文件。</li></ul></li><li><p>数据规约技术</p><ul><li>可以在不损害挖掘结果准确性的前提下，降低数据集的规模，得到简化的数据集。</li><li>维规约技术</li><li>数值规约技术</li><li>数据抽样技术</li></ul></li><li><p>数据转换技术</p><ul><li>包括基于规则或元数据的转换技术、基于模型和学习的转换技术等。</li><li>经过数据转换处理的数据被变换或者统一，简化了处理一分析过程，提升了时效性，也使得数据分析与挖掘的模式更容易被理解。</li></ul></li></ul></li><li><p>数据存储技术</p><ul><li><p>分布式存储技术与数据存储介质的类型以及数据的组织管理形式直接相关</p><ul><li><p>数据存储介质类型</p><ul><li>内存</li><li>磁盘</li><li>磁带等</li></ul></li><li><p>数据组织管理形式</p><ul><li>按行组织</li><li>按列组织</li><li>按键值对组织</li><li>按关系组织等</li></ul></li><li><p>数据组织管理层次</p><ul><li>块级组织</li><li>文件级组织</li><li>数据库级组织等</li></ul></li></ul></li><li><p>分布式文件系统</p><ul><li>HDFS、GFS、KFS、Tachyon（Spark 平台的分布式内存文件系统）</li></ul></li><li><p>文档存储</p><ul><li>MongoDB、CouchDB、Terrastore、RavenDB</li></ul></li><li><p>列式存储</p><ul><li>Sybase IQ、InfiniDB、Vertica、Hadoop HBase、Infobright</li></ul></li><li><p>键值存储</p><ul><li>Redis、Apache Cassandra、Google BigTable</li></ul></li><li><p>图形数据库</p><ul><li>Google Pregel、Neo4j、Infinite Graph、DEX、InfoGrid、AllegroGraph</li></ul></li><li><p>RDB</p></li><li><p>内存存储</p><ul><li>Oracle TimesTen、Altibase、eXtremeDB、Redis、Memcached</li></ul></li></ul></li><li><p>数据处理技术</p><ul><li><p>MapReduce 分布式计算框架</p><ul><li>可动态增加或减少计算节点具有很高的计算弹性，并且具备优秀的任务调度能力和资源分配能力，具有很好的扩展性和容错性。</li><li>确保了数据存储的有效性，减少了数据在网络中的传输开销，还能重新运行失败的任务。</li></ul></li><li><p>分布式内存计算系统</p><ul><li>SAP HANA、Oracle BigData Application</li><li>Spark<br>使用有向无环图（DAG）、迭代计算和内存计算等方式，可以实现一到两个数量级的计算效率提升。</li></ul></li><li><p>分布式流计算系统</p><ul><li>IBM StreamBase、InfoSphere Streams、Twitter Storm、Yahoo S4、Spark Streaming</li></ul></li></ul></li><li><p>数据挖掘技术</p><ul><li><p>数据挖掘（Data Mining）是从大量的、不完全的、有噪声的、模糊的、随机的数据中提取潜在有用的信息的过程。</p></li><li><p>数据挖掘的方法</p><ul><li><p>分类法</p><ul><li><p>把数据分成训练集和测试集，对历史训练集训练，生成分类器，应用到测试集中，对分类器的性能和准确性作出评判。</p></li><li><p>K 最近邻算法（KNN）</p><ul><li>依据最近邻的一个或几个样本的类别决定待分样本所属的类别。</li><li>依靠有限的邻近样本，而不是靠判别类域，适合类域交叉或重叠较多的待分样本。</li></ul></li><li><p>决策树分类法</p><ul><li>应用广泛的归纳推理算法，适合处理类别型变量或连续型变量的分类预测问题。</li></ul></li><li><p>贝叶斯分类法</p><ul><li>用先验概率和类条件概率来表示后验概率。</li></ul></li><li><p>神经网络（Neural Net）</p><ul><li>在环境的激励下，相继给网络输入一些样本模式，并按一定的规则（学习算法）调整网络各层次的权值矩阵，待网络各层权值都收敛到一定值，学习过程就结束。</li></ul></li><li><p>支持向量机（SVM）</p><ul><li>找到一个最优超平面，将两类正确分开，且分类间隔最大。</li></ul></li><li><p>分类算法的评估</p><ul><li>准确率 = 正确预测数 / 预测总数</li></ul></li></ul></li><li><p>关联分析法</p><ul><li><p>支持度和置性度</p></li><li><p>先找出频繁 k 项集，再由频繁项集产生强规则。</p></li><li><p>Apriori 算法</p><ul><li>逐层搜索</li></ul></li><li><p>关联模式的评估</p><ul><li>统计论据 <br> 如对支持度、置信度和相关性的度量</li><li>主观论据 <br> 如可视化、基于模板的方法、主观兴趣度度量</li></ul></li></ul></li><li><p>聚类</p><ul><li><p>与分类的不同在于：聚类所要求划分的类别是未知的，是将数据分到不同的类或簇的一个过程，所以同一个簇中的对象有很大的相似性，而不同簇间的对象有很大的差异性。</p></li><li><p>聚类是数据挖掘的主要任务之一，也可以作为其他算法（如分类）的预处理步骤。</p></li><li><p>常用的聚类算法被分为五类：划分方法、层次方法、基于密度的方法、基于网络的方法和基于模型的方法。</p></li><li><p>K-Means 算法</p><ul><li>将各个聚类子集内的所有数据样本的均值作为该聚类的代表点。不适合处理离散型数据。</li></ul></li><li><p>层次聚类技术</p><ul><li>不产生单一聚类，而是产生一个聚类层次，即一棵层次树。</li></ul></li><li><p>聚类的评价方式</p><ul><li>分析外部信息。直观信息，即聚类结束产生的类别。</li><li>分析内部信息。比较簇类相似性和簇间差异性等。</li></ul></li></ul></li></ul></li></ul></li><li><p>数据分析和数据可视化技术</p><ul><li><p>数据可视化是指将大型数据集里的数据以图形图像形式表示，并利用数据分析和开发工具发现其中未知信息的处理过程。</p></li><li><p>数据可视化技术的基本思想是：将数据库中的每一个数据项作为单个图元素表示，使大量的数据集构成数据图像，同时将数据的各个属性值以多为数据的形式表示，使用户可以从不同的维度观察数据，对数据进行更深入的观察和分析。</p></li><li><p>数据可视化的基本概念</p><ul><li>数据空间。有 n 维属性、m 个元素共同组成的数据集构成的多维信息空间。</li><li>数据开发。使用一定的工具及算法，对数据进行定量推演及计算。</li><li>数据分析。对多为数据进行切片、块、旋转等操作，剖析数据，以从多角度多侧面观察数据。</li><li>数据可视化。将大型数据集里的数据通过图形图像方式表示，并利用数据分析和开发工具发现其中的未知信息。</li></ul></li><li><p>数据可视化的标准</p><ul><li>直观化。将数据直观、形象地呈现出来。</li><li>关联化。突出呈现出数据之间地关联性。</li><li>艺术性。使数据的呈现更具有艺术性，更加符合审美规则。</li><li>交互性。实现用户与数据的交互，方便用户控制数据，</li></ul></li><li><p>数据可视化的作用</p><ul><li>跟大部分项目一样，也是根据需求，基于数据维度或属性进行筛选，并根据目的和用户群选用合适的可视化表现形式，同一份数据可以表现为多种看起来截然不同的形式。</li><li>如果目标是观测、跟踪数据，就要强调实时性、变化和运算能力，最终可能生成一份不停变化、可读性强的图表，如百度地图；</li><li>如果为了分析数据，就要强调数据的呈现度，最终可能生成一份可以检索的交互式图表；</li><li>如果为了发现数据之间的潜在关联，则可能生成一份多维的分布式图表；</li><li>如果为了帮助普通用户或商业用户快速理解数据的含义或变化，可以使用漂亮的颜色和动画，创建生动、明了、具有吸引力的图表，如微软“人立方”展现的人物关系图；</li><li>有些可视化图表可以用于教育、宣传或政治目的，往往制作成海报和课件，出现在街头、广告手持、杂志和集会上，多使用强烈对比、置换等手段，创造出极具冲击力的图像，具有强大的说服力，如媒体根据新闻主题或数据，雇佣设计师创建可视化图表，对新闻主题进行辅助报道。</li></ul></li><li><p>常用的数据分析和可视化工具</p></li></ul></li><li><p>大数据安全</p><ul><li><p>大数据带来的安全挑战</p><ul><li>大数据中的用户隐私保护问题</li><li>大数据的可信性</li><li>大数据的访问控制</li></ul></li><li><p>大数据安全与隐私保护关键技术</p><ul><li>基于大数据的威胁发现技术 </li><li>基于大数据的认证技术</li><li>法律层面的隐私保护技术</li></ul></li></ul></li></ul><h3 id="主流大数据服务"><a href="# 主流大数据服务" class="headerlink" title="主流大数据服务"></a>主流大数据服务</h3><ul><li><p>Google 的技术与产品研发</p><ul><li>Percolator</li><li>Pregel</li><li>Dremel</li></ul></li><li><p>微软的 HDInsight</p></li><li><p>IBM 的 InfoSphere</p></li></ul><h3 id="开源大数据平台"><a href="# 开源大数据平台" class="headerlink" title="开源大数据平台"></a>开源大数据平台</h3><ul><li><p>Hadoop 系统架构</p><ul><li>分布式文件系统 HDFS</li><li>分布式大表存储 HBase</li><li>批处理计算框架 Hadoop MapReduce</li><li>资源管理 YARN</li><li>数据传输、数据分析处理、管理与协同服务等 Avro、Hive、Pig、OoZie、ZooKeeper、Mahout</li><li>Cloudera ADH 版本、Hortonworks HDP 版本</li></ul></li><li><p>Storm 流计算系统</p><ul><li>一个分布式的、容错的实时流计算系统，由 Twitter 正式开源，能够逐条接收和处理数据记录，具有很好的实时响应特性。</li><li>Storm 实时计算被用于“流处理”中，能实时处理消息并更新数据。Storm 借助实时的信息交互与通信组件（如 Kafka、ZeroMQ、Netty 等）对大数据中的记录进行逐条处理，响应实时性可以达到秒级别甚至更短。</li><li>Storm 还能与 HDFS、YARN 有效集成，进一步扩展了其再大数据领域的使用范围。</li></ul></li><li><p>Spark 迭代计算框架</p><ul><li>一个以 MapReduce 计算模型为原型实现的高效迭代计算框架。通过把数据放入内存（RDD，弹性数据集）和有向无环图任务计划安排，大幅度缩减了迭代计算中的 I/O 耗时，提高了任务效率。</li><li>除了能与 HDFS、YARN 有效集成，伯克利大学还为 Spark 提供了支持流处理能力的 Spark Streaming 组件，使其具有了更快的分析、计算和响应速度。</li></ul></li><li><p>其他产品</p></li></ul><h2 id="Hadoop 开发平台"><a href="#Hadoop 开发平台" class="headerlink" title="Hadoop 开发平台"></a>Hadoop 开发平台</h2><h3 id="Hadoop 的发展史"><a href="#Hadoop 的发展史" class="headerlink" title="Hadoop 的发展史"></a>Hadoop 的发展史</h3><h3 id="Hadoop 的功能与作用"><a href="#Hadoop 的功能与作用" class="headerlink" title="Hadoop 的功能与作用"></a>Hadoop 的功能与作用</h3><ul><li><p>HDFS 分布式存储方式，提高了读写速度、扩大了存储容量。具有高容错性，使得 Hadoop 可以部署在低廉的计算机集群中，同时不限于某个操作系统。</p></li><li><p>MapReduce 整合分布式文件系统上的数据，保证分析和处理数据的高效。</p><ul><li>MapReduce 是一种线性的可伸缩的编程模型，程序员编写两个函数——Map 和 Reduce——每一个都定义一个键值对集映射到另一个。这些函数无视数据的大小或者它们正使用的集群的特性，可以原封不动地应用到小规模数据集或者大的数据集上。</li></ul></li><li><p>采用存储冗余数据的方法保证数据的安全性。</p></li><li><p>为什么不用传统数据库加上更多的磁盘来进行大规模批量分析？</p><ul><li>寻址时间（磁头寻道）的提高速度远远慢于传输速率（磁盘带宽）的提高速度。如果数据的访问模式受限于磁盘的寻址，势必会导致耗费更长时间（相较于流）来读或写大部分数据。</li><li>B 树需要使用排序 / 合并来重建数据库，在更新大部分数据库记录时，效率没有 MapReduce 高。</li></ul></li><li><p>在许多情况下，MapReduce 能够被视为一种 RDBMS 的补充。它们有何区别？</p><ul><li>MapReduce 适合处理那些需要分析整个数据集的问题（批处理方式），而 RDBMS 适用于点查询和更新（数据集已经被索引以提供低延迟的检索和短时间的少量数据更新）。<br>MapReduce 适合处理一次写入多次读取的数据，RDBMS 适合持续更新的数据集。</li><li>操作的数据集里的结构化数据的数量不同。MapReduce 处理非结构化或半结构化的数据时非常有效，因为它被设计为在处理时间内解释数据，即 MapReduce 输入的键和值并不是数据固有的属性，而是由分析数据的人来选择的。</li><li>RDBMS 往往是规范的以保持其数据的完整性和消除冗余；而 MapReduce 使用异地操作进行记录的读取，而且核心价值之一就是可以进行高速流式的读写操作。</li><li>RDBMS 和 MapReduce 地差异很可能变得模糊。RDBMS 开始吸收 MapReduce 的一些思路（ASTER DATA 和 GreenPlum 的数据库）；基于 MapReduce 的高级查询语言（如 Pig 和 Hive）使 MapReduce 的系统能够更接近传统的 RDBMS 编程方式。</li></ul></li></ul><h3 id="Hadoop 的基本组成"><a href="#Hadoop 的基本组成" class="headerlink" title="Hadoop 的基本组成"></a>Hadoop 的基本组成</h3><ul><li><p>HDFS（Hadoop 分布式文件系统）</p><ul><li><p>HDFS 是 Hadoop 项目的核心子项目，是分布式计算中数据存储管理的基础。<br>它基于流数据模式访问和处理超大文件的需求而开发，可以运行在廉价的商用服务器上。</p></li><li><p>HDFS 具有的高容错、高可靠性、高可扩展性、高获得性、高吞吐率等特征为海量数据提供了不怕故障的存储，为超大数据集（Large Data Set）的应用处理带来了很多便利。</p></li><li><p>HDFS 的设计目标</p><ul><li><p>检测和快速恢复硬件故障</p><ul><li>数量庞大的服务器意味着高故障率，因此，故障的检测和自动快速就恢复时 HDFS 的一个核心目标。</li></ul></li><li><p>流式的数据访问</p><ul><li>适合进行批量处理，而不是用户交互式的处理，所以重视数据吞吐量，而不是数据访问的速度。</li></ul></li><li><p>简化一致性模型</p><ul><li>一个文件一旦经过创建、写入、关闭后就不需要修改了，从而简化了数据一致性问题和高吞吐量的数据访问问题。</li></ul></li><li><p>通信协议</p><ul><li>建立在 TCP/IP 之上。一个客户端和明确配置了端口的目录节点（NameNode）建立连接之后，它和目录节点（NameNode）的协议便是客户端协议（CP）。数据节点（DataNode）和目录节点（NameNode）之间则用数据节点协议（DP）。</li></ul></li></ul></li><li><p>HDFS 的体系结构</p><ul><li>主从式结构（Master/Slave）</li><li>像传统的 FS 一样，可以通过目录路径对文件置性 CRUD，但由于分布式存储的性质，HDFS 拥有一个 NameNode 和一些 DataNode。NameNode 管理 FS 的元数据，DataNode 存储实际的数据。</li><li>客户端从 NameNode 中获得组成文件数据块的位置列表，再直接从 DataNode 读取文件数据，NameNode 不参与文件的传输。</li><li>一个集群只有一个 NameNode 的设计大大简化了系统。</li></ul></li><li><p>HDFS 的构成组件</p><ul><li><p>数据块</p><ul><li>默认 64M。</li><li>如果一个文件小于一个数据块的大小，该文件并不占用整个数据块的存储空间。</li></ul></li><li><p>NameNode 和 DataNode</p><ul><li><p>NameNode 管理 FS 的命名空间 <br> 将元数据保存在一个文件系统树中</p><ul><li>fsimage<br>截止到自身被创建为止的 HDFS 的最新状态文件</li><li>edits<br>自 fsimage 创建后的 FS 操作日志</li><li>NameNode 每次启动时，都要合并这两个文件，按 edits 的记录更新 fsimage。</li></ul></li><li><p>DataNode 是 FS 中真正存储数据的地方</p><ul><li><p>Client 或者 NameNode 可以向 DataNode 请求写入或读出数据，DataNode 周期性地向 NameNode 汇报其存储地数据块信息。</p></li><li><p>Client 获得地址后直接连接 DataNode 读取数据</p><ul><li>可以将 HDFS 的应用扩展到更大规模的 Client 并行处理，因为数据的流动是在所有 DataNode 之间分散进行的；</li><li>NameNode 的压力也变小了，避免了 NameNode 随着 Client 数量的增长而成为系统的瓶颈。</li></ul></li></ul></li><li><p>读出数据块的处理过程</p><ul><li><p>Client 调用 FileSystem 对象的 open()。FileSystem 是 HDFS 中 DistributedFileSystem 的一个实例。</p></li><li><p>DistributedFileSystem 通过 RPC 协议，调用 NameNode 请求文件块位置。</p><ul><li>NameNode 返回调用文件中开始的几个块而不是全部块。</li><li>每个返回的块都包含块所在的 DataNode 地址，按 Hadoop 定义的集群拓扑结构得出客户端的距离，进行排序。如果 Client 本身就是一个 DataNode，就从本地读取文件。</li><li>DistributedFileSystem 发起一个读取文件的请求，DistributedFileSystem 返回一个支持文件定位的 FSDataInputStream 对象，可以管理 DataNode 和 NameNode 之间的 I/O。</li><li>客户端调用输入流的 read()。</li></ul></li><li><p>DFSInputStream 对象包含文件开始数据块的 DataNode 地址，会连接最近的一个，随后在数据流中重复调用 read()，直到这个块完全读完。</p></li><li><p>第一个块读取完毕时，DFSInputStream 关闭连接，查找下一个距客户端最近的存储数据块的 DataNode。<br>以上步骤对于 Client 是透明的。</p></li><li><p>Client 按照 DFSInputStream 打开连接和 DataNode 返回数据流的顺序读取该块，它也会调用 NameNode 来检索下一组块所在的 DataNode 的位置信息。完成读取时，Client 在 DFSInputStream 调用 close()。</p></li><li><p>如果读取数据时节点出现故障，Client 会尝试连接存储该块的下一个最近的 DataNode，同时记录故障，以免再次连接该节点。</p></li><li><p>Client 还会验证从 DataNode 传送过来的数据的校验和，如果发现一个损坏块，将再次尝试从别的 DataNode 读取数据块，并向 NameNode 报告信息，NameNode 会更新保存的文件信息。</p></li></ul></li><li><p>请求写入数据的处理过程</p><ul><li><p>Client 调用 DistributedFileSystem 对象的 create()，创建一个文件。</p></li><li><p>DistributedFileSystem 通过 RPC 协议，在 NameNode 的 FS ns 中创建一个新文件，此时没有 DataNode 与之相关。</p></li><li><p>NameNode 进行多种验证以保证新建文件不再 FS 中，并确保请求 Client 拥有创建文件的权限。<br>NameNode 创建一个新文件的记录，如果创建失败，抛出 IOException；如果成功，则 DistributedFileSystem 返回一个 FSDataOutputStream。FSDataOutputStream 也包含 DFSOutputStream 对象，处理 DataNode 与 NameNode 的通信。</p></li><li><p>Client 写入数据，DFSOutputStream 将文件分割成包，放入一个内部队列 DataStreamer，由它将文件包放入数据流。</p><ul><li>DataStreamer 的作用是请求 NameNode 为新的文件包分配合适的 DataNode 存放副本，返回的 DataNode 列表形成一个“管道”，假设副本数是 3，管道就有 3 个 DataNode。</li><li>DataStreamer 将文件包以流的方式传送给队列中的第一个 DataNode，第一个 DataNode 会存储这个包，然后推送到第二个 DataNode，依此类推。</li></ul></li><li><p>在传送文件时，DFSOutputStream 也会保存一个包的内部队列，用来等待管道中的 DataNode 返回确认信息，称为确认队列。</p></li><li><p>数据写入节点失败时，关闭管道，任何在确认队列中的文件包都会被添加到数据队列的前端，这样管道中写入失败的 DataNode 都不会丢失数据，而当前存放于正常工作 DataNode 上的文件块被利用，并和 NameNode 关联。</p></li><li><p>如果写入失败的 DataNode 恢复，其中的部分数据块会被删除，管道把失败的 DataNode 删除，文件会继续写入管道中另外两个 DataNode 中。最后，NameNode 会注意到文件块副本数没有达到配置要求，就会重新副本。随后文件就会正常执行写入操作。</p></li><li><p>Client 写入完成后调用 close()。Client 在连接 NameNode 确认之前，将剩下的文件包放入 DataNode 管道，等待通知确认信息。NameNode 会知道那些块组成一个文件（通过 DataStreamer 获得块的位置信息），NameNode 只要在返回成功标志前等待块被最小量（dfs.replication.min）复制即可。</p></li></ul></li></ul></li><li><p>从元数据节点（SecondaryNameNode）</p><ul><li>是 NameNode 的一个工具，帮助 NameNode 管理元数据。</li><li>一般情况下，当 NameNode 重启的时候，会合并 fsimage 文件和 edits 文件，但是，如果集群规模十分庞大，操作频繁，edits 文件会非常大，合并过程慢。</li><li>SecondaryNameNode 定期从 NameNode 上获取元数据，把 edits 文件和 fsimage 文件在本机进行合并，把新的 fsimage 发送回 NameNode。</li></ul></li><li><p>CheckpointNode</p><ul><li>Hadoop 1.0.4 之后使用 CheckPointNode 代替 SecondaryNameNode。配置相同，只是启动命令不同。</li></ul></li><li><p>BackupNode</p><ul><li>内存中维护从 NameNode 同步过来的 fsimage，还从 NameNode 接收 edits 文件的日志流，并存入磁盘。</li><li>会把收到的 edits 文件和内存中的 fsimage 文件合并，创建一份元数据备份。</li><li>BackupNode 还未具备热备功能。</li></ul></li><li><p>JournalNode</p><ul><li><p>解决单点瓶颈。</p></li><li><p>允许同时启动两个 NameNode，分别处于工作状态和待命状态。这些 NameNode 通过共享数据，保证数据的状态一致性。</p></li><li><p>DataNode 必须配置两个 NameNode 地址，发送数据块位置信息和心跳信息。</p></li><li><p>JournalNode 要确保同一时刻只有一个 NameNode 可以向自己写数据。</p></li><li><p>为了部署该类型集群，应进行以下准备</p><ul><li>NameNode 服务器应该具有相同的硬件配置；</li><li>JournalNode 进程非常轻量，可以部署在其他的服务器上。必须运行至少 3 个节点，必须是奇数个。</li><li>standby 状态的 NameNode 可以完成 Checkpoint 操作，没有必要再配置 SecondaryNameNode、CheckpointNode 与 BackupNode。</li></ul></li></ul></li></ul></li><li><p>HDFS 本地存储目录结构</p><ul><li>…</li></ul></li><li><p>HDFS 的安全措施</p><ul><li><p>冗余备份</p><ul><li>当 DataNode 启动时，会遍历本地 FS，产生一份 HDFS 数据块和本地文件对应关系的列表，发送给 NameNode，即报告块（BlockReport）。</li></ul></li><li><p>副本存放</p><ul><li>不同机架上的机器的通信需要通过交换机。采用机架感知（Rack-Aware）策略来提高数据的可靠性、可用性和网络带宽的利用率。</li><li>存放策略是将一个副本存放在本地机架节点上，另一个村常在同一机架的另一个节点上，最后一个存放在不同机架的节点上。</li><li>减少了机架间的数据传输，提高了写操作的效率，而且因为机架的错误远远少于节点，所以这种策略不会影响到数据的可靠性和可用性。</li></ul></li><li><p>心跳检测</p></li><li><p>安全模式</p><ul><li>Hadoop 启动时先进入安全模式，检查数据块的完整性。</li></ul></li></ul></li></ul></li><li><p>MapReduce（分布式计算框架）</p><ul><li>Map 函数被输入键值对映射成一组新的键值对，经过一定的处理后交给 Reduce，对相同的键值对下的所有值进行处理，然后输出键值对作为最终结果。</li></ul></li><li><p>YARN（集群资源管理器）</p><ul><li><p>为上层应用提供统一的资源管理和调度，给集群的利用率、资源统一管理和数据共享等方面带来了巨大的好处。</p></li><li><p>经典的 MapReduce 有以下局限性</p><ul><li>扩展性有限</li><li>利用率有限</li><li>难以支持 MapReduce 以外的运算</li></ul></li></ul></li><li><p>ZooKeeper（分布式协作服务）</p><ul><li><p>一个分布式的服务框架，主要解决分布式集群中应用系统的一致性问题，能提供与目录节点树 FS 类似方式的数据存储。</p></li><li><p>ZooKeeper 不是专门用来存储数据的，它的作用主要是监控所存储数据的状态变化，并通过监控这些变化，实现基于数据的集群管理。</p></li><li><p>ZooKeeper 是一个基于观察者模式设计的分布式服务管理框架，负责存储和管理大家都关心的数据，并接受观察者注册，在数据状态变化时通知观察者，从而实现类似于 Master/Slave 的架构。</p></li><li><p>统一命名服务</p><ul><li>树形名称结构</li></ul></li><li><p>配置管理</p></li><li><p>集群管理</p><ul><li>Leader Election<br>维护集群中机器的服务状态、动态选择 Master</li></ul></li><li><p>共享锁</p></li><li><p>队列管理</p><ul><li>同步队列和 FIFO</li></ul></li></ul></li><li><p>HBase(分布式 NoSQL 数据库)</p><ul><li>适合存储非结构化数据</li><li>使用基于列的模式</li><li>主要用于需要随机访问、实时读写的大数据</li><li>HBase 表是疏松的，用户可以给行定义各种不同的列</li></ul></li><li><p>Hive（数据库管理工具）</p><ul><li>一个建立在 Hadoop 基础之上的数据库，提供了一套对存储在 Hadoop 文件中的数据集进行数据整理、特殊查询和分析的工具。</li><li>提供一种结构化数据的机制，支持 HiveQL。Hive 编译器会把 HiveQL 编译成一组 MapReduce 任务。</li></ul></li><li><p>Pig（高层次抽象脚本语言）</p><ul><li><p>一种用来检索非常大的数据流语言和运行环境，大大简化了 Hadoop 常见的工作任务。Pig 可以加载数据、表达转换数据并存储最终结果，其内置的操作使得半结构化数据变得有意义。</p></li><li><p>Pig 和 Hive 都为 HBase 提供了高层语言支持，使得在 HBase 上进行数据统计处理变得非常简单。二者有何区别？</p><ul><li>Hive 扮演数据库角色，用于静态的结构以及需要经常分析的工作，也可以称为 Hadoop 与其他 BI 工具结合的理想交集。</li><li>Pig 赋予灵活性，允许开发用于转换数据流的简介脚本，以便嵌入到较大的应用程序。Pig 更轻量级，相比直接使用 Hadoop Java API，Pig 可以大幅度削减代码量。</li></ul></li></ul></li><li><p>Avro</p><ul><li>用于数据库序列化的系统。提供了丰富的数据结构类型、快速可压缩的二进制数据格式、存储持久性数据的文件集、远程调用 RPC 的功能何简单的动态语言集成功能。</li><li>Avro 集成动态语言后，读 / 写文件或使用 RPC 协议都不需要生成代码，代码生成既不需要读 / 写文件数据，也不需要使用或实现 RPC 协议，而仅仅是一个可选的对静态类型语言的实现。</li><li>Avro 系统依赖于模式（schema），减少写入数据的开销，提高序列化的速度并缩减其大小，也便于动态脚本语言的使用，因为数据连同其模式都是自描述的。</li><li>在 RPC 中，Avro 系统的客户端和服务端通过握手协议进行模式交换，当客户端和服务端拥有彼此全部的模式时，不同模式下的相同命名字段、丢失字段和附加字段等信息的一致性问题就得到了很好的解决。</li></ul></li><li><p>Sqoop</p><ul><li>Apache SQL-to-Hadoop 项目旨在协助 RDBMS 与 Hadoop 进行高效的大数据交流。</li><li>用户可以把 RDBMS 的数据导入 Hadoop 及其将官的系统（HBase 和 Hive），也可以把数据从 Hadoop 系统抽取并导入 RDBMS。</li><li>Sqoop 也提供了一些实用小工具，如查看数据库等。</li><li>还能将 DB2 的数据导入 HDFS，并保存为多种文件类型如定界文本类型、Avro 二进制类型及 SequenceFiles 类型。</li><li>Sqoop 架构非常简单，整合了 Hive、HBase 和 Oozie，可以通过 MapReduce 任务来传输数据，实现 并发特性和高容错。</li></ul></li></ul><h2 id="MapReduce 应用"><a href="#MapReduce 应用" class="headerlink" title="MapReduce 应用"></a>MapReduce 应用 </h2><h3 id="MapReduce 的主要思想从函数式编程语言借用而来，也包含了矢量编程的特性。极大地方便了编程人员。"><a href="#MapReduce 的主要思想从函数式编程语言借用而来，也包含了矢量编程的特性。极大地方便了编程人员。" class="headerlink" title="MapReduce 的主要思想从函数式编程语言借用而来，也包含了矢量编程的特性。极大地方便了编程人员。"></a>MapReduce 的主要思想从函数式编程语言借用而来，也包含了矢量编程的特性。极大地方便了编程人员。</h3><h3 id="分布式并行编程：编程方式地变革"><a href="# 分布式并行编程：编程方式地变革" class="headerlink" title="分布式并行编程：编程方式地变革"></a> 分布式并行编程：编程方式地变革</h3><ul><li><p>分布式并行环境的最大优点</p><ul><li>可以很容易地通过增加计算机来扩充新的计算节点，并由此获得不可思议地海量计算能力；</li><li>具有相当强地容错能力，即使有一批计算节点失效，也不会影响计算的整体正常进行以及结果的正确性。</li></ul></li><li><p>Google 就使用 MapReduce 的并行编程模型，进行分布式并行编程。它运行在名为 GFS 的分布式 FS 上，为全球亿万用户提供搜索服务。</p></li><li><p>Hadoop 也实现了 MapReduce 编程模型，提供了简单、易用的编程接口以及自己的 DFS HDFS。</p></li></ul><h3 id="MapReduce 模型概述"><a href="#MapReduce 模型概述" class="headerlink" title="MapReduce 模型概述"></a>MapReduce 模型概述</h3><ul><li><p>适用于 MapReduce 处理的数据集（或者任务）需要满足一个基本要求：<br>待处理的数据集可以分解成许多小的数据集，且每一个小数据集都可以完全并行地处理。</p></li><li><p>一个 MapReduce 作业（Job）通常会把输入的数据集切分为若干独立的数据块，由 Map 任务（Task）完全并行地处理；<br>MapReduce 框架会对 Map 的输出进行排序，把结果输入给 Reduce 任务。通常作业的输入和输出存储在 FS 中，而由整个框架负责任务的调度和监控，并重新执行已经失败的任务。</p></li><li><p>通常 MapReduce 框架和 DFS 运行在一组相同节点</p><ul><li>计算节点和存储节点通常在一起，使 MapReduce 框架在那些已经存储了数据的节点上高效地调度任务，使整个集群地网络带宽得到非常高效的利用。</li></ul></li><li><p>MapReduce 框架由一个单独的 Master JobTracker 和每个集群节点各一个 Slave TaskTracker 共同完成</p><ul><li>唯一的 Master 负责调度构成一个作业的所有任务，而这些任务分布在不同的 Slave 上，Master 监控它们的执行并重新执行已经失败的任务，而 Slave 仅负责执行由 Master 指派的任务。</li></ul></li><li><p>应用程序应指明输入 / 输出的位置（路径），并通过实现合适的接口或抽象类提供 Map 和 Reduce 函数，再加上其他作业的参数，构成作业配置（Job configuration）；<br>然后，Hadoop 的 Job Client 会将作业（Jar 包 / 可执行程序等）和配置信息提交给 JobTracker，后者负责将这些程序和配置信息发给 Slave，调度任务并监控它们的执行，同时将状态和诊断信息提供给 Job Client。</p></li><li><p>MapReduce 程序不一定使用 Java 编写</p></li><li><p>MapReduce 计算模型的核心使 Map 和 Reduce 函数。以一个统计文本单词的程序为例，可以是：<br>&lt; 行在文件中的偏移, 文件中的一行 &gt;<br>↓map()<br>List&lt; 单词, 出现次数 &gt;<br>↓<br>&lt; 单词, List&lt; 出现次数 &gt;&gt;<br>↓reduce()<br>&lt; 单词, 出现次数 &gt;</p></li><li><p>基于 MapReduce 计算模型编写分布式并行程序非常简单</p><ul><li>程序员不用操心分布式存储、工作调度、负载均衡、容错处理、网络通信等问题。</li></ul></li></ul><h3 id="工作组件"><a href="# 工作组件" class="headerlink" title="工作组件"></a>工作组件</h3><ul><li><p>Client</p><ul><li>运行 MapReduce 程序和 JobClient。</li><li>主要提交 MapReduce 作业并为用户显示处理结果。</li></ul></li><li><p>ResourceManager</p><ul><li>主要进行 MapReduce 作业执行的调度工作。</li><li>功能包括指定 MapReduce 作业计划、将任务分配给 Map()和 Reduce()执行、执行节点监控任务、重新分配失败的任务等。</li><li>对集群中所有资源进行统一管理与分配，将各类资源（计算、内存、带宽等）精心安排给基础 NodeManager（YARN 的每节点代理）。</li><li>还与 ApplicationMaster 一起分配资源，并接收 NodeManager 的资源汇报信息，然后按一定策略分配给各个应用程序。</li><li>ResourceManager 是 Hadoop 集群中十分重要的节点，每个集群只能有一个 ResourceManager。</li></ul></li><li><p>NameNode</p><ul><li>管理 FS 的 ns（元数据），维护整个 FS 的文件目录树以及这些文件的索引目录，并记录文件和目录的拥有者、权限、文件包含的块的个数、块的副本数以及决定数据块到具体 DataNode 节点的映射等，同时也负责管理 Client 对文件的访问。</li></ul></li><li><p>ApplicationMaster</p><ul><li>管理在 YARN 内运行的应用程序实例，协调来自 RedourceManager 的资源，并通过 NodeManager 监视程序的执行和资源使用情况（CPU、内存等的分配）。</li></ul></li><li><p>NodeManager</p><ul><li>机器框架代理，执行应用程序的容器，监控应用程序的资源使用情况（CPU、内存、硬盘、网络等），向调度器汇报。</li></ul></li><li><p>DataNode</p><ul><li>处理 FS 的读写请求，数据块创建、删除和复制。</li><li>启动时扫描磁盘，汇报数据块信息；发送心跳信息（3s），如果 10 分钟未收到心跳信息，认为已失效。</li></ul></li><li><p>Container</p><ul><li>YARN 中资源的抽象，封装了一定量的资源（CPU 和内存）。</li><li>运行 ApplicationMaster 的 Container，由 ResourceManager 向内部的资源调度器申请并启动，用户提交应用程序时，可指定唯一的 ApplicationMaster 所需的资源；</li><li>运行各类任务的 Container，由 ApplicationMaster 向 ResourceManager 申请，并由 ApplicationMaster 与 NodeManager 通信以启动。</li><li>两类 Container 的位置一般是随机的，ApplicationMaster 可能与它管理的任务运行在同一节点。</li></ul></li></ul><h3 id="MapReduce 工作流程"><a href="#MapReduce 工作流程" class="headerlink" title="MapReduce 工作流程"></a>MapReduce 工作流程</h3><ul><li><p>MapReduce 采用了分治算法</p></li><li><p>工作流程概述</p><ul><li>Mapping 任务是平等的，任意 Mapper 都可以处理任意的输入文件。Mapper 会加载本地运行节点的文件集来处理。</li><li>Mapping 阶段完成后，把具有相同键的数值发送到同一个 Reducer。Map 或 Reduce 任务间不进行信息交换，以确保 Hadoop MapReduce 的可靠性。</li></ul></li><li><p>MapReduce 任务的执行流程</p><ul><li><p>JobTracker<br>在分布式环境中实现 Client 任务的创建和提交</p></li><li><p>InputFormat<br>进行 Map 前的预处理</p><ul><li>验证输入数据的格式是否符合 JobConfig 的输入数据定义，可以是专门定义的类或是 Writable 的子类；</li><li>将输入的文件切分为多个逻辑上的输入 InputSplit（IS），因为在 DFS 中，数据块大小是有限制的，所以大文件需要被划分为多个较小的数据块；</li><li>使用 RecordReader（RR）来处理切分为 IS 的一组记录并将结果输出给 Map，因为 IS 只是逻辑切分的第一步，根据文件中的信息进行具体切分还需要 RR 来完成。</li></ul></li><li><p>将 RR 处理后的结果作为 Map 的输入数据，Map 执行 Map 逻辑，将键值对结果输入到临时中间文件。</p></li><li><p>Shuffle&amp;Partitioner</p><ul><li>为了让 Reduce 能并行处理 Map 结果，必须对 Map 的输出结果进行一定的排序和分割，再交给对应的 Reduce。这一整理过程，称为 Shuffle。</li><li>Partitioner 是选择配置，主要在有多个 Reduce 情况下，指定 Map 的结果由某一个 Reduce 处理。每一个 Reduce 都会有单独的输出文件。</li></ul></li><li><p>Reduce 执行具体的业务逻辑，将处理结果输入给 OutputFormat。</p><ul><li>OutputFormat 验证输出目录是否存在，并检查输出结果类型是否符合 Config 中的配置类型。如果通过，输出 Reduce 汇总结果。</li></ul></li></ul></li><li><p>MapReduce 过程包含的部分</p><ul><li><p>输入文件</p><ul><li>一般存储在 HDFS 里。</li><li>格式是任意的，基于行的日志文件、二进制格式、多行输入记录等。</li><li>数十 GB 或更大。</li></ul></li><li><p>输入格式</p><ul><li><p>定义了如何分割和读取输入文件。</p></li><li><p>选择输入的文件或对象；</p></li><li><p>定义把文件划分到任务的 IS；</p></li><li><p>为 RR 读取文件提供一个工厂方法。</p></li><li><p>FileInputFormat<br>Hadoop 启动时，FIF 得到一个路径参数，包含了需要处理的文件，FIF 将这些文件拆分成一个或多个 IS。</p><ul><li>TextInputFormat&lt; 行偏移, 行 &gt;<br>默认格式，适合未格式化或基于行的数据，如 log。</li><li>KeyValueInputFormat&lt; 第一个 Tab 前的字符串, 行剩余内容 &gt;<br>适合传递 Map 结果。</li><li>SequenceFileInputFormat&lt; 自定义, 自定义 &gt;<br>用于处理特殊的、专用于 Hadoop 的 SequenceFile 类型的二进制文件。这些文件能让 Mapper 快速读取数据；并且是块压缩的，能对几种数据类型直接进行序列化与反序操作。<br>这些文件也可以作为 MapReduce 任务的输出数据，作为到另一个 MapReduce 作业的中间数据。</li></ul></li></ul></li><li><p>输入块</p><ul><li>一个 IS 描述了 MapReduce 程序中单个 Map 任务的一个单元，Map 任务一般读取文件的一部分。</li><li>默认 FIF 以 64MB 未基数拆分（Hadoop 建议分片（Split）大小与 HDFS 数据块大小相同）。可以在 xml 或 JobConf 指定。</li><li>通过以块形式处理文件，可以让多个 Map 任务并行地操作一个文件；多个数据块可以分散到不同节点，可以把任务调度在不同地节点上。有些文件不支持块处理方式，需要自定义 InputFormat，以控制文件的拆分（或不拆分）。</li><li>输入格式定义了组成 Mapping 阶段的 Map 任务列表，每一个任务对应一个输入块。根据文件块物理地址，任务被分派到对应的系统节点，多个 Map 任务可以分派到同一节点。</li></ul></li><li><p>记录读取器</p><ul><li>IS 定义了如何切分工作，但是没有描述如何访问；RR 类则用来加载数据，并转换为适合 Mapper 读取的键值对。</li><li>RR 实例由输入格式定义，默认的 TIF 提供了一个类 LineRecordReader，把输入文件处理为 &lt; 行偏移, 行 &gt;。RR 在输入块上重复调用，直到整个块处理完毕，每一次 RR 都会调用 Mapper 的 map()。</li></ul></li><li><p>Mapper</p><ul><li>对于整个作业输入部分的每一个 Map 任务（输入块），每一个新的 Mapper 实例都会在单独的 Java 进程中初始化。</li><li>Mapper 之间不进行通信每一个 Map 任务的可靠性不受其他 Map 任务的影响，只由本地机器的可靠性决定。</li></ul></li><li><p>Partition&amp;Shuffle</p><ul><li>当第一个 Map 任务完成，节点可能还要继续执行更多的 Map 任务，但也要开始把 Map 任务的中间结果作进一步整理，输出到需要它们的 Reducer 中，这个把 Map 输出作进一步整理并移交到 Reducer 中的过程叫做 Shuffle。</li><li>每一个 Reduce 节点会分配到 Map 输出的间集合中的一个子集（Partitions），它们各不相同，是 Reduce 任务的输入数据。</li><li>每一个 Map 任务生成的键值对，可能会隶属于任意的 Partition，有着相同键的数值总是在一起执行 Reduce 任务，不管来自哪个 Mapper。Partitioner 类就决定给定键值对去向，默认的分类器（Partitioner）计算键的 Hash 值来赋值给 Partition。</li></ul></li><li><p>Reducer</p><ul><li>对关联到相同键上的数值进行规约（Reducing），每个节点收到的中间结果集合已经被 Hadoop 排序。每个 Reducer 任务创建一个 Reducer 实例。</li><li>对于每一个已被赋予到 Reduce 的 Partition 内的键，Reducer 的 reduce()只会调用一次，接收一个迭代器，它会以一个未定义的顺序返回关联到同一个键的值。</li><li>Reducer 也要接收 OutputCollecter 对象和 Report 对象，它们像在 map()中那样被使用。</li></ul></li><li><p>输出格式</p><ul><li><p>控制提供给 OutputCollector 的键值对写入文件的方式。</p></li><li><p>每一个 Reducer 把结果输出写在公共文件夹中一个单独的文件“part-nnnnn”，”nnnnn“是关联到 Reduce 任务的 Partition 的 ID。</p></li><li><p>FileOutputFormat</p><ul><li>TextOutputFormat<br>默认方式，每行一个键值对。可以通过 KeyValueInputFormat 类重新读取。</li><li>SequenceFileFormat<br>快速地序列化任意地数据类型，对应的 SequenceFileInputFormat 把文件反序为相同类型，并提交为下一个 Mapper 的输入数据。</li><li>NullOutputFormat<br>不会生成输出文件，且丢弃任何通过 OutputCollector 传递给它的键值对。适合要在 reduce()显示地编写自定义输入文件，又不希望 Hadoop 框架输出额外的空输出文件。</li></ul></li></ul></li><li><p>RecordWriter</p><ul><li>与 InputFormat 中通过 RR 读取单个记录相似，OutputFormat 类是 RecordWriter 对象的工厂方法，用来把单个记录写到文件中，就像是由 OutputFormat 直接写入。</li></ul></li></ul></li><li><p>shuffle 过程详解</p><ul><li>…</li></ul></li></ul><h3 id="并行计算的实现"><a href="# 并行计算的实现" class="headerlink" title="并行计算的实现"></a>并行计算的实现</h3><ul><li><p>数据分布存储</p><ul><li>Block 分散存储于 DataNode</li><li>NameNode 维护元数据</li></ul></li><li><p>分布式并行计算</p><ul><li><p>Hadoop 由中 JobTracker 调度和管理其他的 TaskTracker。负责执行任务的 TaskTracker 必须运行在 DataNode 上。</p></li><li><p>在进行 MapReduce 任务调度时，要保证 Master 节点的 NameNode、SecondaryNameNode、JobTracker 和 Slave 节点的 DataNode、TaskTracker 都已启动。</p></li><li><p>MapReduce 任务调度包括以下两步</p><ul><li><p>JobClient 提交作业</p><ul><li><p>runJob(job)实例化 JobClient</p></li><li><p>submitJob(job)像 JobTracker 提交作业</p></li><li><p>返回 RunningJob 对象，跟踪作业状态</p></li><li><p>submitJobInternal(job)向 HDFS 依次上传三个文件</p><ul><li><p>job.jar</p><ul><li>执行此任务的类，如 Mapper、Reducer 等实现</li></ul></li><li><p>job.split</p><ul><li>文件分块相关信息，如块数、块的大小</li></ul></li><li><p>job.xml</p><ul><li>有关的作业配置，如 Mapper、Combiner、Reducer 的类型、输入 / 输出格式的类型</li></ul></li></ul></li></ul></li><li><p>JobTracker 调度作业</p><ul><li>等待 JobClient 通过 RPC 提交作业</li><li>submitJob(job)产生一个 JobInProgress 对象，代表一项作业，可维护这道作业的所有信息，包括作业相关信息 JobProfile 和最近作业状态 JobStatus；将规划所有作业的 Task 登记到任务列表。</li><li>将 JobInProgress 对象通过 listener.jobAdded(job)加入调度队列，用一个成员变量 jobs 维护所有的作业。</li><li>等到 TaskTracker 空闲，使用 JobTracker.assignTask(TaskTracker)请求任务，如果调度队列不空，程序便通过调度算法取出一个 Task 任务交给请求的 TaskTracker。</li></ul></li></ul></li></ul></li><li><p>本地计算</p></li><li><p>任务粒度</p></li><li><p>Partition</p></li><li><p>Combine</p><ul><li>在 Partition 之前，可以对中间结果进行合并。Combiner 是可选的，主要在每一个 Map 执行完分析后，在本地优先作 Reduce 的工作，减少中间结果键值对的数目。Combine 过程于 Reduce 类似，但是作为 Map 任务的一部分，紧接着 Map 函数。</li></ul></li><li><p>Reduce 任务</p><ul><li>Map 任务的中间结果在完成 Combine 和 Partition 之后，以文件形式保存，将位置通知给主控 JobTracker，由 JobTracker 通知 Reduce 任务。</li><li>每个 Reduce 从多个 Map 任务节点获取落在其负责的键区间内的中间结果，执行 Reduce 函数，形成最终的结果文件。</li></ul></li></ul><h3 id="WordCount"><a href="#WordCount" class="headerlink" title="WordCount"></a>WordCount</h3><ul><li>…</li></ul><h3 id="MapReduce 新框架 YARN"><a href="#MapReduce 新框架 YARN" class="headerlink" title="MapReduce 新框架 YARN"></a>MapReduce 新框架 YARN</h3><ul><li>…</li></ul><h2 id="小节"><a href="# 小节" class="headerlink" title="小节"></a>小节 </h2><h3 id="云计算——约翰·麦卡锡（John-McCarthy）"><a href="# 云计算——约翰·麦卡锡（John-McCarthy）" class="headerlink" title="云计算——约翰·麦卡锡（John McCarthy）"></a> 云计算——约翰·麦卡锡（John McCarthy）</h3><p>大数据——吉姆·格雷（Jim Gray）</p><h3 id="云计算时代基本的三种角色"><a href="# 云计算时代基本的三种角色" class="headerlink" title="云计算时代基本的三种角色"></a>云计算时代基本的三种角色</h3><ul><li>整合运营者</li><li>资源使用者</li><li>终端用户</li></ul><h3 id="科学研究范式"><a href="# 科学研究范式" class="headerlink" title="科学研究范式"></a>科学研究范式</h3><ul><li>观测实验</li><li>理论（计算萌芽）</li><li>计算仿真（面向数据）</li><li>数据（面向计算）</li></ul><h3 id="生产数据的三个阶段"><a href="# 生产数据的三个阶段" class="headerlink" title="生产数据的三个阶段"></a>生产数据的三个阶段</h3><ul><li>被动</li><li>主动</li><li>感知</li></ul><h3 id="云计算的基本原理"><a href="# 云计算的基本原理" class="headerlink" title="云计算的基本原理"></a>云计算的基本原理</h3><ul><li>将计算分布在大量的分布式计算机上，而非本地计算机或远程服务器中，企业数据中心的运行将更相似于互联网。这使得企业能够将资源切换到需要的应用上，根据需求访问计算机和存储系统。</li></ul><h3 id="云计算的特点 -1"><a href="# 云计算的特点 -1" class="headerlink" title="云计算的特点"></a>云计算的特点 </h3><h3 id="云计算的分类 -1"><a href="# 云计算的分类 -1" class="headerlink" title="云计算的分类"></a> 云计算的分类</h3><ul><li>按所有权</li><li>按服务类型</li></ul><h3 id="大数据的两个基本特征"><a href="# 大数据的两个基本特征" class="headerlink" title="大数据的两个基本特征"></a>大数据的两个基本特征 </h3><h3 id="主流的云计算和大数据供应商及云服务内容"><a href="# 主流的云计算和大数据供应商及云服务内容" class="headerlink" title="主流的云计算和大数据供应商及云服务内容"></a> 主流的云计算和大数据供应商及云服务内容 </h3><h3 id="云计算与大数据的关系 -1"><a href="# 云计算与大数据的关系 -1" class="headerlink" title="云计算与大数据的关系"></a> 云计算与大数据的关系 </h3><h3 id="虚拟化技术的概念及优势"><a href="# 虚拟化技术的概念及优势" class="headerlink" title="虚拟化技术的概念及优势"></a> 虚拟化技术的概念及优势 </h3><h3 id="虚拟化技术从计算体系结构层次上的分类"><a href="# 虚拟化技术从计算体系结构层次上的分类" class="headerlink" title="虚拟化技术从计算体系结构层次上的分类"></a> 虚拟化技术从计算体系结构层次上的分类</h3><table><thead><tr><th></th><th>虚拟化出的目标对象</th><th>所处位置</th><th>实例</th></tr></thead><tbody><tr><td>指令集架构级虚拟化</td><td>指令集</td><td>指令集架构级</td><td>Bochs、VLIW</td></tr><tr><td>硬件级虚拟化</td><td>计算机的各种硬件</td><td>应用层</td><td>VMWare、Virtual PC、Xen、KVM</td></tr><tr><td>操作系统级虚拟化</td><td>操作系统</td><td>本地操作系统内核</td><td>Virtual Server、Zone、Virtuozzo</td></tr><tr><td>编程语言级虚拟化</td><td>应用层的部分功能</td><td>应用层</td><td>JVM、CLR</td></tr><tr><td>库函数级虚拟化</td><td>应用级库函数的接口</td><td>应用层</td><td>应用层</td></tr></tbody></table><h3 id="集群的概念和分类"><a href="# 集群的概念和分类" class="headerlink" title="集群的概念和分类"></a>集群的概念和分类</h3><ul><li><p>集群系统是一组独立的计算机（节点）的集合体，节点间通过高性能的互联网络连接，各节点除了作为一个单一的计算资源供交互式用户使用外，还可以协同工作，并表示为一个单一的、集中的计算资源，供并行计算任务使用。</p></li><li><p>集群系统是一种造价低廉、易于构建并且具有较好可扩放性的体系结构。</p></li><li><p>高可用性集群系统</p><ul><li>节点冗余来实现</li><li>主要用于支撑关键性业务，保证相关业务的不间断服务。</li></ul></li><li><p>负载均衡集群系统</p><ul><li>所有节点都参与工作</li><li>系统通过管理节点（利用轮询算法、最小负载优先算法等调度算法）或利用类似一致性哈希等负载均衡算法实现整个集群系统系统内负载的均衡分配。</li></ul></li><li><p>高性能集群系统</p><ul><li>追求整个集群系统系统计算能力的强大，其目的是完成复杂的计算任务</li><li>在科学计算中常用的集群系统。目前物理、生物、化学等领域有大量的高性能集群系统提供服务。</li></ul></li><li><p>虚拟化集群系统</p><ul><li>实现服务器资源的充分利用和切分</li><li>将一台服务器利用虚拟化技术分割为多台独立的虚拟机使用，并通过管理软件实现虚拟资源的分配和管理。这类集群系统称为虚拟集群系统，其计算资源和存储资源通常是在一台物理机上。利用虚拟化集群系统可以实现虚拟桌面技术等云计算的典型应用。</li></ul></li></ul><h3 id="HDFS 基本体系结构"><a href="#HDFS 基本体系结构" class="headerlink" title="HDFS 基本体系结构"></a>HDFS 基本体系结构</h3><h3 id="HDFS 工作过程"><a href="#HDFS 工作过程" class="headerlink" title="HDFS 工作过程"></a>HDFS 工作过程</h3><h3 id="HDFS 默认副本数量和分块策略"><a href="#HDFS 默认副本数量和分块策略" class="headerlink" title="HDFS 默认副本数量和分块策略"></a>HDFS 默认副本数量和分块策略</h3><h3 id="ZooKeeper 的应用场景、解决的问题"><a href="#ZooKeeper 的应用场景、解决的问题" class="headerlink" title="ZooKeeper 的应用场景、解决的问题"></a>ZooKeeper 的应用场景、解决的问题</h3><h3 id="HBase 和 RDBMS 的区别"><a href="#HBase 和 RDBMS 的区别" class="headerlink" title="HBase 和 RDBMS 的区别"></a>HBase 和 RDBMS 的区别</h3><ul><li><p>数据类型</p><ul><li>HBase 只有简单的字符串类型，它只保存字符串所有的类型都是交给用户自己处理</li></ul></li><li><p>数据操作</p><ul><li>HBase 操作只有很简单的插入、查询等操作，表与表之间是分离的，没有 join</li></ul></li><li><p>存储模式</p><ul><li>HBase 基于列存储，每个列族由几个文件保存，不同列族的文件是分离的</li></ul></li><li><p>数据维护</p><ul><li>HBase 更新操作时，旧的版本仍然保留，实际上是插入了新数据</li></ul></li><li><p>数据伸缩性</p><ul><li>HBase 就是为这个目的而开发出来的，它能够很轻松的增加或减少硬件的数量，有很高的容错机制。传统的数据库需要加中间层才能达到这个效果</li></ul></li></ul><h3 id="Hadoop 安装过程"><a href="#Hadoop 安装过程" class="headerlink" title="Hadoop 安装过程"></a>Hadoop 安装过程</h3><ul><li>ssh 免密通信</li><li>设置防火墙</li><li>JDK 和 Hadoop 安装</li><li>Hadoop 配置</li><li>格式化 NameNode</li><li>启动并验证</li><li>运行 MapReduce 测试实例 wordcount</li></ul><h3 id="MapReduce 的工作流程"><a href="#MapReduce 的工作流程" class="headerlink" title="MapReduce 的工作流程"></a>MapReduce 的工作流程</h3><h3 id="Pig 的两个主要组成部分、两种运行模式"><a href="#Pig 的两个主要组成部分、两种运行模式" class="headerlink" title="Pig 的两个主要组成部分、两种运行模式"></a>Pig 的两个主要组成部分、两种运行模式</h3><ul><li><p>高级数据处理语言 Pig Latin</p><ul><li>Pig 针对 MapReduce 算法（框架）开发的一套 Shell 脚本，类似用户熟悉的 SQL 语句，可以对加载完毕的数据进行排序、过滤、求和、分组、关联等操作。</li><li>易于编程</li><li>自动优化</li><li>可扩展性</li></ul></li><li><p>依据可供抽样的评价机制编译与运行 Pig Latin 脚本的编译器</p></li><li><p>Local 模式</p><ul><li>在单个 JVM 中访问本地 FS，用于测试或处理小规模数据集。</li></ul></li><li><p>MapRedduce 模式</p><ul><li>默认模式，可以访问整个 Hadoop 集群，处理大规模数据集。</li></ul></li></ul><h3 id="SMP、MPP"><a href="#SMP、MPP" class="headerlink" title="SMP、MPP"></a>SMP、MPP</h3><ul><li>MPP，大规模并行处理计算机（Massive Parallel Processor），由大量通用微处理器构成的多处理机系统，适合多指令流多数据流处理。</li><li>MPP 通常是一种无共享（Shared-Nothing）的体系结构，节点可以有多种硬件构成方式，不过大多数只有主存和处理器。</li><li>SMP，对称多处理（Symmetrical Multi-Processing），指在一个计算机上汇集了一组处理器（多 CPU），各 CPU 之间共享内存子系统以及总线结构。它是相对非对称多处理技术而言的、应用十分广泛的并行技术。</li><li>SMP 可以认为是一种完全共享（Shared-Everything）的体系结构，所有的处理器共享所有可用的全局资源（总线、内存和 I/O 等）。</li><li>对于集群来说，集群的节点复杂度通常比 MPP 高，因为各集群节点都有自己的本地磁盘和完整的操作系统；<br>MPP 的节点通常没有磁盘，并且可以只是使用一个微内核，而不是一个完整的操作系统；<br>SMP 服务器则比一个集群节点要复杂，因为它有更多的外设终端，如终端、打印机和外部 RAID 等。</li></ul><h3 id="NFS、GFS"><a href="#NFS、GFS" class="headerlink" title="NFS、GFS"></a>NFS、GFS</h3><ul><li>NFS，网络文件系统（Network File System），是由 SUN 公司研制的 UNIX 表示层协议（presentation layer protocol），能使使用者访问网络上别处的文件就像在使用自己的计算机一样。</li><li>NFS 是基于 UDP/IP 协议的应用，其实现主要是采用远程过程调用 RPC 机制，RPC 提供了一组与机器、操作系统以及低层传送协议无关的存取远程文件的操作。RPC 采用了 XDR 的支持。XDR 是一种与机器无关的数据描述编码的协议，他以独立与任意机器体系结构的格式对网上传送的数据进行编码和解码，支持在异构系统之间数据的传送。</li></ul><h3 id="HPCC、MPI、ssh"><a href="#HPCC、MPI、ssh" class="headerlink" title="HPCC、MPI、ssh"></a>HPCC、MPI、ssh</h3><ul><li>MPI，消息传递接口（Message Passing Interface），是一个跨语言的通讯协议，用于编写并行计算机。支持点对点和广播。</li><li>MPI 是一个信息传递应用程序接口，包括协议和和语义说明，他们指明其如何在各种实现中发挥其特性。MPI 的目标是高性能，大规模性，和可移植性。MPI 在今天仍为高性能计算的主要模型。</li><li>主要的 MPI-1 模型不包括共享内存概念，MPI-2 只有有限的分布共享内存概念。 但是 MPI 程序经常在共享内存的机器上运行。在 MPI 模型周边设计程序比在 NUMA 架构下设计要好因为 MPI 鼓励内存本地化。</li><li>尽管 MPI 属于 OSI 参考模型的第五层或者更高，他的实现可能通过传输层的 sockets 和 Transmission Control Protocol (TCP)覆盖大部分的层。大部分的 MPI 实现由一些指定惯例集（API）组成，可由 C、C++、Fortran 或者有此类库的语言比如 C#、 Java 或 Python 直接调用。<br>MPI 优于老式信息传递库是因为他的可移植性和速度。</li><li>HPCC，高性能计算集群（High-PerformanceComputingCluster），也称为数据分析超级计算机（DAS），是由 LexisNexis 风险解决方案开发的开源，数据密集型计算系统平台。</li><li>HPCC 平台整合了在商品计算集群上实现的软件架构，为使用大数据的应用程序提供高性能的数据并行处理。HPCC 平台包括支持并行批处理数据处理（Thor）和使用索引数据文件（Roxie）的高性能在线查询应用程序的系统配置。HPCC 平台还包含一个以数据为中心的并行数据处理声明性编程语言 ECL。</li><li>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。</li><li>利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 最初是 UNIX 系统上的一个程序，后来又迅速扩展到其他操作平台。SSH 在正确使用时可弥补网络中的漏洞。SSH 客户端适用于多种平台。几乎所有 UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行 SSH。</li></ul><h3 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h3><ul><li> UDF，用户自定义函数（User Defined Function）。此概念出现在 MySQL、Interbase、Firebird、Fluent 中，根据用户实际应用的需要而自行开发函数。</li></ul><p><em>XMind - Trial Version</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统</title>
      <link href="notes/ji-suan-ji-cao-zuo-xi-tong/"/>
      <url>notes/ji-suan-ji-cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统引论"><a href="# 操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论 </h2><h3 id="操作系统的目标"><a href="# 操作系统的目标" class="headerlink" title="操作系统的目标"></a> 操作系统的目标</h3><ul><li>方便性</li><li>有效性</li><li>可扩充性</li><li>开放性</li></ul><h3 id="操作系统的作用"><a href="# 操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ul><li><p>作为用户与计算机硬件系统之间的接口</p><ul><li>命令接口</li><li>程序接口（系统调用）</li><li>图形接口</li></ul></li><li><p>作为计算机系统资源的管理者</p><ul><li>处理机</li><li>存储器</li><li>I/O 设备</li><li>文件（数据和程序）</li></ul></li><li><p>实现了对计算机资源的抽象</p><ul><li>扩充机器</li></ul></li></ul><h3 id="推动操作系统发展的主要动力"><a href="# 推动操作系统发展的主要动力" class="headerlink" title="推动操作系统发展的主要动力"></a>推动操作系统发展的主要动力</h3><ul><li>不断提高计算机资源利用率</li><li>方便用户</li><li>器件的不断更新迭代</li><li>计算机体系结构的不断发展</li><li>不断提出新的应用需求（嵌入式等）</li></ul><h3 id="操作系统的发展过程"><a href="# 操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h3><ul><li><p>未配置操作系统的计算机系统</p><ul><li><p>人工操作方式</p><ul><li>串行</li><li>用户独占全机</li><li>CPU 等待人工操作</li><li>人机矛盾</li></ul></li><li><p>脱机输入 / 输出（Off-Line I/O）方式</p><ul><li><p>并行</p></li><li><p>假脱机</p></li><li><p>优势</p><ul><li>减少了 CPU 的空闲时间（外围机）</li><li>提高了 I/O 速度（高速磁带）</li></ul></li></ul></li></ul></li><li><p>单道批处理系统</p><ul><li><p>处理过程</p><ul><li>监督程序</li></ul></li><li><p>特点</p><ul><li>自动</li><li>顺序</li><li>单道</li></ul></li><li><p>缺点</p><ul><li>系统中的资源得不到充分利用</li></ul></li></ul></li><li><p>多道批处理系统（Multiprogrammed Batch Processing System）</p><ul><li><p>基本概念</p><ul><li>后备队列</li><li>就绪队列</li><li>作业调度程序</li><li>调度算法</li></ul></li><li><p>特点</p><ul><li>多道</li><li>无序</li><li>调度</li></ul></li><li><p>优缺点</p><ul><li>资源利用率高</li><li>系统吞吐量大</li><li>平均周转时间长</li><li>无交互能力</li></ul></li><li><p>解决问题</p><ul><li>处理机争用问题</li><li>内存分配和保护问题</li><li>I/O 设备分配问题</li><li>文件的组织和管理问题</li><li>作业管理问题</li><li>用户与系统的接口问题</li></ul></li><li><p>引入操作系统定义</p><ul><li><p>应在计算机系统中增加一组软件，用以对上述问题进行妥善、有效的处理。</p></li><li><p>这组软件应包括</p><ul><li>能有效地组织和管理四大资源地软件</li><li>合理地对各类作业进行调度和控制它们运行的软件</li><li>方便用户使用计算机的软件</li></ul></li><li><p>操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。</p></li></ul></li></ul></li><li><p>分时系统</p><ul><li><p>引入</p><ul><li>人——机交互</li><li>共享主机</li><li>分时系统是指：在一台主机上连接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互的方式使用计算机，共享主机中的资源。</li></ul></li><li><p>问题</p><ul><li><p>及时接收</p><ul><li>多路卡</li><li>终端缓冲区</li></ul></li><li><p>及时处理</p><ul><li>作业直接进入内存</li><li>轮转运行</li></ul></li></ul></li><li><p>特征</p><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li></ul></li></ul></li><li><p>实时系统</p><ul><li><p>指系统能及时相应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p></li><li><p>类型</p><ul><li>工业（武器）控制系统</li><li>信息查询系统</li><li>多媒体系统</li><li>嵌入式系统</li></ul></li><li><p>实时任务的类型</p><ul><li>周期性实时任务和非周期性实时任务</li><li>硬实时任务（HRT）和软实时任务（SRT）</li></ul></li><li><p>与分时系统特征的比较</p><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li><li>可靠性</li></ul></li></ul></li><li><p>微机操作系统的发展</p><ul><li>单用户单任务 OS</li><li>单用户多任务 OS</li><li>多用户多任务 OS</li></ul></li></ul><h3 id="操作系统的基本特征"><a href="# 操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h3><ul><li><p>并发</p><ul><li>多个进程之间可以并发执行和交换信息</li></ul></li><li><p>共享</p><ul><li>互斥共享</li><li>同时访问</li></ul></li><li><p>虚拟</p><ul><li><p>时分复用技术</p><ul><li>虚拟处理机技术</li><li>虚拟设备技术</li><li>多道程序技术</li></ul></li><li><p>空分复用技术</p><ul><li><p>虚拟存储技术</p><ul><li>逻辑上扩大存储容量</li><li>单纯的空分复用存储器只能提高内存的利用率</li></ul></li></ul></li></ul></li><li><p>异步</p><ul><li>不可预知</li><li>进程同步机制</li></ul></li></ul><h3 id="操作系统的主要功能"><a href="# 操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><ul><li><p>处理机管理功能</p><ul><li>进程控制</li><li>进程同步</li><li>进程通信</li><li>调度</li></ul></li><li><p>存储器管理功能</p><ul><li>内存分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充</li></ul></li><li><p>设备管理功能</p><ul><li>缓冲管理</li><li>设备分配</li><li>设备处理</li></ul></li><li><p>文件管理功能</p><ul><li>文件存储空间的管理</li><li>目录管理</li><li>文件的读 / 写管理和保护</li></ul></li><li><p>OS 与用户之间的接口</p><ul><li><p>用户接口</p><ul><li>联机用户接口</li><li>脱机用户接口</li><li>图形用户接口</li></ul></li><li><p>程序接口</p></li></ul></li><li><p>现代 OS 的新功能</p><ul><li><p>系统安全</p><ul><li>认证技术</li><li>密码技术</li><li>访问控制技术</li><li>反病毒技术</li></ul></li><li><p>网络的功能和服务</p><ul><li>网络通信</li><li>资源管理</li><li>应用互操作</li></ul></li><li><p>支持多媒体</p><ul><li>接纳控制功能</li><li>实时调度</li><li>多媒体文件的存储</li></ul></li></ul></li></ul><h3 id="OS 结构设计"><a href="#OS 结构设计" class="headerlink" title="OS 结构设计"></a>OS 结构设计</h3><ul><li><p>传统 OS 结构</p><ul><li>无结构 OS</li><li>模块化结构 OS</li><li>分层式 OS</li></ul></li><li><p>C/S 模式简介</p><ul><li>由来、组成和类型</li><li>交互</li><li>优点</li></ul></li><li><p>OOP 技术简介</p><ul><li>基本概念</li><li>优点</li></ul></li><li><p>微内核 OS 结构</p><ul><li><p>基本概念</p><ul><li><p>足够小的内核</p></li><li><p>基于 C/S 模式</p><ul><li>消息传递</li></ul></li><li><p>应用“机制与策略分离”原理</p></li><li><p>采用 OO 技术</p></li></ul></li><li><p>基本功能</p><ul><li>进程（线程）管理</li><li>低级存储器管理</li><li>中断和陷入处理</li></ul></li><li><p>优点</p><ul><li>提高了系统的可扩展性</li><li>增强了系统的可靠性</li><li>可移植性强</li><li>提供了对分布式系统的支持</li><li>融入了 OO 技术</li></ul></li><li><p>存在的问题</p><ul><li><p>效率降低</p><ul><li>可以重新把一些常用的 OS 基本功能有服务器移入微内核中</li></ul></li></ul></li></ul></li></ul><h2 id="进程的描述与控制"><a href="# 进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制 </h2><h3 id="程序执行"><a href="# 程序执行" class="headerlink" title="程序执行"></a> 程序执行</h3><ul><li><p>程序顺序执行</p><ul><li>顺序性</li><li>封闭性</li><li>可再现性</li></ul></li><li><p>程序并发执行</p><ul><li>间断性</li><li>失去封闭性</li><li>不可再现性</li></ul></li></ul><h3 id="进程的描述"><a href="# 进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h3><ul><li><p>定义</p><ul><li><p>引入</p><ul><li>为了使程序并发执行，并且可以对并发执行的程序加以描述和控制</li></ul></li><li><p>进程实体</p><ul><li><p>程序段</p></li><li><p>相关的数据段</p></li><li><p>PCB</p><ul><li>描述进程的基本状况和活动过程，系统进而控制和管里进程</li></ul></li></ul></li><li><p>定义</p><ul><li><p>传统</p></li><li><p>引入进程实体</p><ul><li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</li></ul></li></ul></li></ul></li><li><p>特征</p><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ul></li><li><p>进程的基本状态及转换</p></li><li><p>进程管理中的数据结构</p><ul><li><p>OS 中用于管理控制的数据结构</p></li><li><p>PCB</p><ul><li><p>记录了 OS 所需的，用于描述进程的当前情况以及管理进程运行的全部信息，是 OS 中最重要的记录型数据结构。</p></li><li><p>PCB 的作用是使一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。</p><ul><li>作为独立运行基本单位的标志</li><li>能实现间断性运行方式</li><li>提供进程管理所需要的信息</li><li>提供进程调度所需要的信息</li><li>实现与其他进程的同步与通信</li></ul></li></ul></li><li><p>PCB 中的信息</p><ul><li><p>进程标识符</p><ul><li>外部标识符</li><li>内部标识符</li></ul></li><li><p>处理机状态</p><ul><li>通用寄存器</li><li>指令寄存器</li><li>程序状态字 PSW</li><li>用户栈指针</li></ul></li><li><p>进程调度信息</p><ul><li>进程状态</li><li>进程优先级</li><li>进程调度所需的其他信息</li><li>事件</li></ul></li><li><p>进程控制信息</p><ul><li>程序和数据的地址</li><li>进程同步和通信机制</li><li>资源清单</li><li>链接指针</li></ul></li></ul></li><li><p>PCB 的组织方式</p><ul><li>线性方式</li><li>链接方式</li><li>索引方式</li></ul></li></ul></li></ul><h3 id="进程控制"><a href="# 进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul><li><p>OS 内核</p><ul><li><p>将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块，安排在紧靠硬件的软件层次中，常驻内存。</p><ul><li>便于对这些软件进行保护，防止遭受其他应用程序的破坏</li><li>可以提高 OS 的运行效率</li></ul></li><li><p>功能</p><ul><li><p>支撑功能</p><ul><li><p>中断处理</p></li><li><p>时钟管理</p></li><li><p>原语操作</p><ul><li>原语是由若干条指令组成的、用于完成一定功能的一个过程</li></ul></li></ul></li><li><p>资源管理功能</p><ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul></li></ul></li><li><p>进程的创建</p><ul><li><p>进程的层次结构、进程图</p></li><li><p>引起创建进程的事件</p><ul><li>用户登录</li><li>作用调度</li><li>提供服务</li><li>应用请求</li></ul></li><li><p>进程的创建</p></li></ul></li><li><p>进程的终止</p><ul><li><p>引起进程终止的事件</p><ul><li><p>正常结束</p></li><li><p>异常结束</p><ul><li>越界错</li><li>保护错</li><li>非法指令</li><li>特权指令错</li><li>运行超时</li><li>等待超时</li><li>算术运算错</li><li>I/O 故障</li></ul></li><li><p>外界干预</p><ul><li>操作员或 OS 干预</li><li>父进程请求</li><li>因父进程终止</li></ul></li></ul></li><li><p>进程的终止过程</p></li></ul></li><li><p>进程的阻塞与唤醒</p><ul><li><p>引起进程阻塞和唤醒的事件</p><ul><li>向系统请求共享资源失败</li><li>等待某种操作的完成</li><li>新数据尚未到达</li><li>等待新任务的到达</li></ul></li><li><p>进程阻塞过程</p></li><li><p>进程唤醒过程</p></li></ul></li><li><p>进程的挂起与激活</p></li></ul><h3 id="进程同步"><a href="# 进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ul><li><p>主要任务</p><ul><li>对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好地相互合作，从而使程序地执行具有可再现性。</li></ul></li><li><p>两种形式的制约关系</p><ul><li>间接相互制约关系</li><li>直接相互制约关系</li></ul></li><li><p>临界资源</p></li><li><p>临界区</p><ul><li>在每个进程中访问临界资源的代码</li><li>进入区 <br> 临界区 <br> 退出区 <br> 剩余区</li></ul></li><li><p>同步机制应遵循的规则</p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul></li><li><p>硬件同步机制</p><ul><li>关中断</li><li>TS</li><li>Swap 指令</li></ul></li><li><p>信号量（Semaphores）机制</p><ul><li><p>整型信号量</p><ul><li>为遵循“让权等待”</li></ul></li><li><p>记录型信号量</p></li><li><p>AND 型信号量</p><ul><li>需要多个共享临界资源</li></ul></li><li><p>信号量集</p></li><li><p>信号量的应用</p><ul><li>进程互斥</li><li>前趋关系</li></ul></li></ul></li><li><p>管程机制</p><ul><li><p>信号量需要进程自备同步操作。使得大量的同步操作分散在各个进程中。不仅给系统的管理带来了麻烦，还会因同步操作使用不当而导致系统死锁。</p></li><li><p>管程的定义</p><ul><li><p>可以利用共享数据结构抽象地表示系统中的共享资源，并将对该共享数据结构实施的特定操作定义为一组过程。</p></li><li><p>进程对共享资源的申请、释放和其他操作必须通过这组过程，间接地对共享数据结构实现操作。</p></li><li><p>对于请求访问共享资源的诸多并发进程，可以根据资源的情况接收或阻塞，确保每次仅有一个进程进入管程，执行这组过程，使用共享资源，达到对共享资源所有访问的统一管理，有效地实现进程互斥。</p></li><li><p>组成</p><ul><li>管程名称</li><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li></ul></li></ul></li><li><p>语言角度的特性</p><ul><li>模块化</li><li>抽象数据类型</li><li>信息掩蔽</li></ul></li><li><p>和进程的不同</p><ul><li>公共数据结构</li><li>进程使由顺序程序执行有关操作，管程主要进行同步操作初始化操作</li><li>设置进程在于实现系统的并发性，设置管程是解决共享资源的互斥使用问题</li><li>进程调用管程的过程，管程为被动工作方式</li><li>管程不能于其调用者并发</li><li>进程具有动态性，管程则是 OS 中的一个资源管理模块，供进程调用</li></ul></li><li><p>条件变量</p></li></ul></li></ul><h3 id="经典进程的同步问题"><a href="# 经典进程的同步问题" class="headerlink" title="经典进程的同步问题"></a>经典进程的同步问题 </h3><h3 id="进程通信"><a href="# 进程通信" class="headerlink" title="进程通信"></a> 进程通信</h3><ul><li><p>指进程之间的信息交换</p></li><li><p>互斥与同步</p><ul><li>效率低</li><li>通信对用户不透明</li><li>称为低级进程通信</li></ul></li><li><p>高级通信工具的特点</p><ul><li>使用方便</li><li>高效传送大量数据</li></ul></li><li><p>高级通信</p><ul><li><p>共享存储器系统</p><ul><li><p>基于共享数据</p><ul><li>少量数据</li><li>效率低下</li><li>属于低级通信</li></ul></li><li><p>基于共享存储区</p><ul><li>由进程负责</li></ul></li></ul></li><li><p>管道（pipe）通信系统</p><ul><li><p>需提供以下协调能力</p><ul><li>互斥</li><li>同步</li><li>确定对方是否存在</li></ul></li></ul></li><li><p>消息传递系统</p><ul><li>直接通信</li><li>间接通信</li></ul></li><li><p>C-S 系统</p><ul><li><p>Socket</p><ul><li>基于文件型</li><li>基于网络型</li></ul></li><li><p>RPC</p></li></ul></li></ul></li><li><p>消息传递通信的实现方式</p></li><li><p>直接消息传递系统实例</p></li></ul><h3 id="线程的基本概念"><a href="# 线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h3><ul><li><p>引入</p><ul><li><p>引入进程是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量；引入线程则是为了减少程序在并发执行时付出的时空开销，使 OS 具有更好的并发性。</p></li><li><p>进程的两个基本属性</p><ul><li>是一个可拥有资源的基本单位</li><li>是一个可独立调度和分派的基本单位</li></ul></li><li><p>程序并发执行所需付出的时空开销</p><ul><li>创建</li><li>撤销</li><li>切换</li></ul></li><li><p>线程——作为调度和分派的基本单位</p></li></ul></li><li><p>比较</p><ul><li>调度的基本单位</li><li>并发性</li><li>拥有资源</li><li>独立性</li><li>系统开销</li><li>支持多处理机系统</li></ul></li><li><p>线程的状态和 TCB</p><ul><li><p>状态</p><ul><li>执行</li><li>就绪</li><li>阻塞</li></ul></li><li><p>TCB</p><ul><li>线程标识符</li><li>一组寄存器：PC、状态寄存器和通用寄存器的内容</li><li>运行状态</li><li>优先级</li><li>线程专有存储区</li><li>信号屏蔽</li><li>堆栈指针</li></ul></li><li><p>多线程 OS 中的进程属性</p><ul><li>是一个可拥有资源的基本单位</li><li>多个线程可并发执行，进程有一个或多个线程</li><li>进程已不再是可执行的实体</li></ul></li></ul></li></ul><h3 id="线程的实现"><a href="# 线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><ul><li><p>内核支持线程（KST）</p><ul><li><p>在内核的支持下运行</p></li><li><p>调度以线程为单位</p></li><li><p>优点</p><ul><li>在多处理机系统中，内核支持调度统一进程中的多个线程并行执行</li><li>进程中的一个线程阻塞时，内核可以调度该进程中的其他线程占有处理器，或运行其他进程中的线程</li><li>具有很小的数据结构和堆栈，线程切换开销小</li><li>内核本身也可以采用多线程技术，以提高系统的执行速度和效率</li></ul></li><li><p>缺点</p><ul><li>对于用户线程，切换开销大</li></ul></li></ul></li><li><p>用户级线程（ULT）</p><ul><li><p>在用户空间实现，与内核无关</p></li><li><p>调度仍以进程为单位</p></li><li><p>优点</p><ul><li>切换不需要转换到内核空间</li><li>调度算法可以是进程专用的</li><li>实现与 OS 平台无关，因为线程管理代码是用户程序的一部分。甚至可以实现在不支持线程机制的 OS 平台 ULT</li></ul></li><li><p>缺点</p><ul><li>系统调用的阻塞问题。同一进程的其他线程均阻塞</li><li>在单纯的 ULT 实现方式中，不能利用多处理机进行多重处理。内核每次分配各一个进程一个 CPU</li></ul></li></ul></li><li><p>组合方式</p><ul><li><p>多对一模型</p><ul><li>开销小</li><li>阻塞问题</li><li>多处理机问题</li></ul></li><li><p>一对一模型</p><ul><li>阻塞</li><li>多处理机</li><li>创建开销大</li></ul></li><li><p>多对多模型</p></li></ul></li><li><p>实现</p></li><li><p>创建和终止</p></li></ul><h2 id="处理机调度与死锁"><a href="# 处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁 </h2><h3 id="处理机调度算法的目标"><a href="# 处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a> 处理机调度算法的目标</h3><ul><li><p>共同目标</p><ul><li>资源利用率</li><li>公平性</li><li>平衡性</li><li>策略强制执行</li></ul></li><li><p>批处理系统</p><ul><li><p>平均周转时间短</p><ul><li>平均周转时间</li><li>平均带权周转时间</li></ul></li><li><p>系统吞吐量高</p><ul><li>短作业</li></ul></li><li><p>处理机利用率高</p><ul><li>大作业</li></ul></li></ul></li><li><p>分时系统</p><ul><li>响应时间快</li><li>均衡性</li></ul></li><li><p>实时系统</p><ul><li>截止时间的保证</li><li>可预测性</li></ul></li></ul><h3 id="作业调度"><a href="# 作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><ul><li><p>批处理系统中的作业</p><ul><li>作业</li><li>作业步</li><li>JCB</li><li>三个阶段和状态</li></ul></li><li><p>作业调度的主要任务</p><ul><li><p>任务</p></li><li><p>调度时做出决定</p><ul><li><p>接纳多少个作业</p><ul><li>取决于多道作业度</li></ul></li><li><p>接纳哪些作业</p><ul><li>取决于调度算法</li></ul></li></ul></li><li><p>各系统的不同</p></li></ul></li><li><p>调度算法</p><ul><li><p>先来先服务（FCFS）调度算法</p><ul><li>与其他调度算法结合使用</li></ul></li><li><p>短作业优先（SJF）调度算法</p><ul><li><p>缺点</p><ul><li>须预知作业的运行时间</li><li>对长作业不利</li><li>无法实现人——机交互</li><li>完全为考虑作业的紧迫程度</li></ul></li></ul></li><li><p>优先级调度算法（PSA）</p></li><li><p>高响应比优先调度算法（HRRN）</p><ul><li>既考虑作业的等待时间，又考虑运行时间</li><li>Rp = (等待时间 + 要求服务时间) / 要求服务时间<br>= 响应时间 / 要求服务时间</li><li>SJF、FCFS、长作业折中</li><li>调度前有系统开销</li></ul></li></ul></li></ul><h3 id="进程调度"><a href="# 进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ul><li><p>进程调度</p><ul><li><p>任务</p><ul><li>保存处理机现场信息</li><li>按某种算法选取进程</li><li>把处理机分配给进程</li></ul></li><li><p>机制</p></li><li><p>方式</p><ul><li><p>非抢占方式</p><ul><li><p>引起调度的因素</p><ul><li>正在执行的进程完毕或无法继续运行</li><li>正在执行的进程提出 I/O 请求</li><li>进程通信或同步中，执行原语操作</li></ul></li><li><p>实现简单，系统开销小</p></li><li><p>不适用于分时系统和大多数实时系统</p></li></ul></li><li><p>抢占方式</p><ul><li><p>广泛使用</p></li><li><p>抢占方式复杂，系统开销大</p></li><li><p>主要原则</p><ul><li>优先权原则</li><li>短进程优先原则</li><li>时间片原则</li></ul></li></ul></li></ul></li></ul></li><li><p>调度算法</p><ul><li><p>轮转调度算法</p></li><li><p>优先级调度算法</p><ul><li>非抢占式和抢占式</li><li>静态优先级和动态优先级</li></ul></li><li><p>多队列调度算法</p><ul><li>多个就绪队列</li></ul></li><li><p>多级反馈队列（multileved feelback queue）调度算法</p><ul><li>不必事先知道进程所需的执行时间</li><li>多级</li><li>反馈</li><li>性能</li></ul></li><li><p>基于公平原则的调度算法</p><ul><li><p>保证调度算法</p><ul><li>针对进程</li></ul></li><li><p>公平共享调度算法</p><ul><li>针对用户</li></ul></li></ul></li></ul></li></ul><h3 id="实时调度"><a href="# 实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><ul><li><p>基本条件</p><ul><li><p>提供必要的信息</p><ul><li>就绪时间</li><li>开始截止时间和完成截止时间</li><li>处理时间</li><li>资源要求</li><li>优先级</li></ul></li><li><p>系统处理能力强</p><ul><li>及时处理</li></ul></li><li><p>采用抢占式调度机制</p></li><li><p>具有快速切换机制</p><ul><li>对中断的快速响应能力</li><li>快速的任务分派能力</li></ul></li></ul></li><li><p>调度算法分类</p><ul><li><p>非抢占式</p><ul><li>非抢占式轮转调度算法</li><li>非抢占式优先调度算法</li></ul></li><li><p>抢占式</p><ul><li>基于时钟中断</li><li>立即抢占</li></ul></li></ul></li><li><p>调度算法</p><ul><li><p>最早截止时间优先（EDF）算法</p><ul><li><p>分抢占式</p><ul><li>用于非周期实时任务</li></ul></li><li><p>抢占式</p><ul><li>用于周期实时任务</li></ul></li></ul></li><li><p>最低松弛度优先（LLF）算法</p><ul><li>松弛度 = 必须完成时间 - 运行时间 - 当前时间</li></ul></li><li><p>优先级倒置（priority inversion problem）</p><ul><li>动态优先级继承</li></ul></li></ul></li></ul><h3 id="死锁"><a href="# 死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><p>资源问题</p></li><li><p>死锁起因</p></li><li><p>定义</p></li><li><p>必要条件</p></li><li><p>处理方法</p><ul><li><p>预防死锁</p></li><li><p>避免死锁</p></li><li><p>检测死锁</p><ul><li>死锁的充分条件</li></ul></li><li><p>解除死锁</p></li></ul></li></ul><h2 id="存储器管理"><a href="# 存储器管理" class="headerlink" title="存储器管理"></a>存储器管理 </h2><h3 id="程序的装入"><a href="# 程序的装入" class="headerlink" title="程序的装入"></a> 程序的装入</h3><ul><li><p>绝对装入（Absolute Loading Mode）</p><ul><li>单道运行</li><li>逻辑地址与实际地址相同</li></ul></li><li><p>可重定位装入（Relocation Loading Mode）</p><ul><li>静态重定位</li></ul></li><li><p>动态运行时装入（Dynamic Run-time Loading）</p><ul><li>运行中改变位置</li></ul></li></ul><h3 id="程序的链接"><a href="# 程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><ul><li><p>静态链接（Static Linking）方式</p><ul><li><p>装配时</p><ul><li>对相对地址进行修改</li><li>变换外部符号引用</li></ul></li></ul></li><li><p>装入时动态链接（Load-time Dynamic Linking）</p><ul><li>便于修改和更新</li><li>便于实现对目标模块的共享</li></ul></li><li><p>运行时动态链接（Run-time Dynamic Linking）</p><ul><li>链接推迟到执行时</li></ul></li></ul><h3 id="连续分配存储器管理方式"><a href="# 连续分配存储器管理方式" class="headerlink" title="连续分配存储器管理方式"></a>连续分配存储器管理方式</h3><ul><li><p>单一连续分配</p><ul><li>单用户、单任务</li></ul></li><li><p>固定分区分配</p><ul><li><p>划分分区的方法</p><ul><li>大小相等</li><li>大小不等</li></ul></li><li><p>内存分配</p><ul><li>分区使用表</li></ul></li><li><p>造成空间浪费。适用于某些控制相同对象的系统</p></li></ul></li><li><p>动态分区分配</p><ul><li><p>数据结构</p><ul><li>空闲分区表</li><li>或空闲分区链</li></ul></li><li><p>分配算法</p><ul><li><p>基于顺序搜索的动态分区分配算法</p><ul><li><p>首次适应（FF）算法</p><ul><li>将空闲分区链以地址递增链接</li><li>为大作业分配创造了条件</li><li>外零头，增加查找开销</li></ul></li><li><p>循环首次适应（NF）算法</p><ul><li>使空闲分区更均匀</li><li>缺乏大的空闲分区</li></ul></li><li><p>最佳适应（BF）算法</p><ul><li>将空闲分区按容量小到大形成空闲分区链</li><li>留下许多难以利用的碎片</li></ul></li><li><p>最坏适应（WF）算法</p><ul><li>缺乏大的分区</li><li>产生碎片的可能性小</li><li>查找效率高</li></ul></li></ul></li><li><p>基于索引搜索的动态分区分配算法</p><ul><li><p>快速适应（quick fit）算法</p><ul><li>容量分类</li><li>管理所有表</li><li>无碎片</li><li>查找效率高</li><li>分区归还算法复杂，系统开销大</li><li>空间浪费</li></ul></li><li><p>伙伴系统（buddy system）</p><ul><li>可以多次分割和合并</li><li>时间性能比快速适应差</li><li>空间性能优于快速适应</li></ul></li><li><p>Hash 算法</p></li></ul></li></ul></li><li><p>分配操作</p></li></ul></li><li><p>动态可重定位分区分配</p><ul><li><p>紧凑</p></li><li><p>动态重定位</p></li><li><p>分配算法</p><ul><li>紧凑功能</li></ul></li></ul></li></ul><h3 id="对换"><a href="# 对换" class="headerlink" title="对换"></a>对换 </h3><h3 id="分页存储管理方式"><a href="# 分页存储管理方式" class="headerlink" title="分页存储管理方式"></a> 分页存储管理方式 </h3><h3 id="分段存储管理方式"><a href="# 分段存储管理方式" class="headerlink" title="分段存储管理方式"></a> 分段存储管理方式 </h3><h2 id="虚拟存储器"><a href="# 虚拟存储器" class="headerlink" title="虚拟存储器"></a> 虚拟存储器 </h2><h3 id="常规存储管理方式的特征"><a href="# 常规存储管理方式的特征" class="headerlink" title="常规存储管理方式的特征"></a> 常规存储管理方式的特征</h3><ul><li><p>一次性</p><ul><li>大作用无法运行</li><li>无法进一步提高多道程序度</li></ul></li><li><p>驻留性</p><ul><li>进程阻塞，长期等待</li><li>不必要模块</li></ul></li></ul><h3 id="局部性原理"><a href="# 局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li><p>在一段较短的时间内，程序的执行仅限于某个部分，相应地，它所访问的存储空间也局限于某个区域。</p></li><li><p>顺序执行</p><ul><li>存储单元，空间局限性</li></ul></li><li><p>过程调用</p><ul><li>调用深度，运行范围局限</li></ul></li><li><p>循环结构</p><ul><li>再次执行，时间局限性</li></ul></li><li><p>数据结构</p><ul><li>处理范围局限</li></ul></li></ul><h3 id="虚拟存储器的定义和特征"><a href="# 虚拟存储器的定义和特征" class="headerlink" title="虚拟存储器的定义和特征"></a>虚拟存储器的定义和特征</h3><ul><li><p>指具有调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存和外存之和决定，运行速度接近于内存速度，每位成本接近于外存。</p></li><li><p>多次性</p><ul><li>多次调入，逻辑上扩充</li></ul></li><li><p>对换性</p><ul><li>换进换出，提高利用率</li></ul></li><li><p>虚拟性</p><ul><li><p>逻辑容量</p><ul><li>大作业</li><li>多道程序度</li></ul></li><li><p>内存利用率</p></li><li><p>并发程度</p><ul><li>系统吞吐量</li></ul></li></ul></li></ul><h3 id="分页请求系统"><a href="# 分页请求系统" class="headerlink" title="分页请求系统"></a>分页请求系统</h3><ul><li><p>是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统</p></li><li><p>实现方法</p><ul><li><p>离散分配存储管理方式</p></li><li><p>硬件支持</p><ul><li>请求分页的页表机制</li><li>缺页中断机构</li><li>地址变换机构</li></ul></li><li><p>请求分页的软件</p><ul><li>请求调页</li><li>页面置换</li></ul></li></ul></li></ul><h3 id="请求分页存储管理方式"><a href="# 请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><ul><li><p>硬件支持</p><ul><li><p>请求页表机制</p><ul><li>状态位 P</li><li>访问字段 A</li><li>修改位 M</li><li>外存地址</li></ul></li><li><p>缺页中断机构</p><ul><li>缺页中断在指令执行期间产生和处理中断信号</li><li>一条指令在执行期间可产生多次缺页中断</li></ul></li><li><p>地址变换机构</p></li></ul></li><li><p>内存分配</p><ul><li><p>最小物理块数</p></li><li><p>内存分配策略</p><ul><li><p>固定分配局部置换</p><ul><li>物理块数难以确定</li></ul></li><li><p>可变分配全局置换</p><ul><li>易于实现</li><li>可能影响其他进程</li></ul></li><li><p>可变分配局部置换</p></li></ul></li><li><p>物理块分配算法</p><ul><li>平均分配</li><li>按比例分配</li><li>考虑优先权</li></ul></li></ul></li><li><p>调入策略</p><ul><li><p>何时调入页面</p><ul><li>预调页策略</li><li>请求调页策略</li></ul></li><li><p>从何处调入页面</p><ul><li><p>对换区</p><ul><li>足够对换空间</li></ul></li><li><p>文件区</p><ul><li>缺少对换空间</li></ul></li><li><p>UNIX 方式</p><ul><li>凡未运行过的页面均从文件区调页</li><li>运行过的页面和换出的页面均从对换区调页</li></ul></li></ul></li><li><p>页面调入过程</p></li><li><p>缺页率</p></li></ul></li></ul><h3 id="页面置换算法"><a href="# 页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul><li><p>最佳（Optimal）置换算法</p><ul><li>理论上的</li></ul></li><li><p>FIFO 页面置换算法</p></li><li><p>最近最久未使用（LRU）置换算法</p><ul><li><p>“向前看”近似将来</p></li><li><p>硬件支持</p><ul><li>寄存器</li><li>栈</li></ul></li></ul></li><li><p>最少使用（LFU）置换算法</p><ul><li>记录时间间隔内的使用</li></ul></li><li><p>Clock 置换算法</p><ul><li><p>LRU 的近似算法</p></li><li><p>简单的 Clock 置换算法</p><ul><li>为每页设置访问位，将内存页面链接成循环队列</li><li>最近未使用算法或 NRU 算法</li></ul></li><li><p>改进型 Clock 置换算法</p><ul><li>增加修改位</li></ul></li></ul></li><li><p>页面缓冲算法（PBA）</p><ul><li><p>影响页面换进换出效率的若干因素</p><ul><li>页面置换算法</li><li>写回磁盘的频率</li><li>读入内存的频率</li></ul></li><li><p>PBA</p><ul><li><p>显著降低了页面换进、换出的频率</p></li><li><p>可采用较简单的置换策略，如 FIFO，它不需要特殊硬件支持</p></li><li><p>VAX/VMS OS</p><ul><li>可变分配局部置换</li><li>空闲页面链表</li><li>修改页面链表</li></ul></li></ul></li></ul></li><li><p>访问内存的有效时间</p></li></ul><h3 id="“抖动”与工作集"><a href="#“抖动”与工作集" class="headerlink" title="“抖动”与工作集"></a>“抖动”与工作集</h3><ul><li><p>多道程序度和处理机的利用率</p></li><li><p>产生“抖动”的原因</p></li><li><p>工作集</p><ul><li><p>基本概念</p></li><li><p>定义</p><ul><li>指在某段时间间隔里，进程实际所要访问页面的集合。</li></ul></li></ul></li><li><p>“抖动”的预防方法</p><ul><li><p>采取局部置换策略</p><ul><li>把“抖动”的影响限制在较小的范围，效果不是很好</li></ul></li><li><p>把工作集算法融入到处理机调度中</p><ul><li>调入作业之前，检查每个进程在内存的驻留页面是否足够多</li></ul></li><li><p>利用“L = S”准则调节缺页率</p></li><li><p>选择暂停的进程</p><ul><li>优先级低的</li><li>不十分重要，但较大的</li><li>剩余执行时间最多的</li></ul></li></ul></li></ul><h2 id="输入输出系统"><a href="# 输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><h3 id="I-O 系统的功能、模型和接口"><a href="#I-O 系统的功能、模型和接口" class="headerlink" title="I/O 系统的功能、模型和接口"></a>I/O 系统的功能、模型和接口</h3><ul><li><p>管理的主要对象</p><ul><li>I/O 设备</li><li>相应的设备管理器</li><li>I/O 通道</li></ul></li><li><p>最主要的任务</p><ul><li>完成用户提出的 I/O 请求</li><li>提高 I/O 速率</li><li>提高设备的利用率</li><li>并能为更高层的进程方便地使用这些设备提供手段</li></ul></li><li><p>基本功能</p><ul><li><p>隐藏物理设备的细节</p><ul><li>设备差异</li><li>需要的命令和参数</li></ul></li><li><p>与设备的无关性</p><ul><li>用户使用 I/O 抽象命令、逻辑设备名</li><li>提高 OS 的可移植性和易适应性</li></ul></li><li><p>提高处理机和 I/O 设备的利用率</p><ul><li><p>处理机和 I/O 设备并行工作</p><ul><li>快速响应用户请求，使 I/O 设备运行起来</li><li>减少 I/O 设备运行时处理机的干预时间</li></ul></li></ul></li><li><p>对 I/O 设备进行控制</p><ul><li><p>驱动程序</p><ul><li>四种控制方式</li></ul></li><li><p>I/O 软件应屏蔽方式的差异</p></li></ul></li><li><p>确保对设备的正确共享</p><ul><li>独占设备和共享设备</li></ul></li><li><p>错误处理</p><ul><li>临时性和持久性</li></ul></li></ul></li><li><p>层次结构和模型</p></li><li><p>I/O 系统接口</p></li></ul><h3 id="I-O 设备和设备控制器"><a href="#I-O 设备和设备控制器" class="headerlink" title="I/O 设备和设备控制器"></a>I/O 设备和设备控制器</h3><ul><li><p>I/O 设备</p><ul><li>类型</li><li>设备与设备控制器之间的接口</li></ul></li><li><p>设备控制器</p></li><li><p>内存映像 I/O</p></li><li><p>I/O 通道</p></li></ul><h3 id="中断机构和中断处理程序"><a href="# 中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h3><ul><li>中断简介</li><li>中断处理程序</li></ul><h3 id="设备驱动程序"><a href="# 设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><ul><li><p>概述</p></li><li><p>处理过程</p><ul><li>将抽象 I/O 请求转换为具体要求，发送给设备控制器，或相反</li></ul></li><li><p>对 I/O 设备的控制方式</p><ul><li><p>使用轮询的可编程 I/O 方式（程序 I/O）</p><ul><li>CPU 种无中断机构</li></ul></li><li><p>使用中断的可编程 I/O 方式</p><ul><li>数据寄存器</li></ul></li><li><p>直接存储器（DMA）访问</p><ul><li>数据块</li></ul></li><li><p>I/O 通道（IOP）控制方式</p><ul><li>一组数据块</li></ul></li></ul></li></ul><h3 id="与设备无关的 I-O 软件"><a href="# 与设备无关的 I-O 软件" class="headerlink" title="与设备无关的 I/O 软件"></a>与设备无关的 I/O 软件</h3><ul><li><p>基本概念</p></li><li><p>与设备无关的软件</p><ul><li>数据粒度</li></ul></li><li><p>设备分配</p></li><li><p>映射实现</p></li></ul><h3 id="用户层的 I-O 软件"><a href="# 用户层的 I-O 软件" class="headerlink" title="用户层的 I/O 软件"></a>用户层的 I/O 软件</h3><ul><li><p>系统调用和库函数</p></li><li><p>假脱机（Spooling）系统</p><ul><li><p>假脱机技术</p><ul><li>外围控制机</li><li>联机实现</li></ul></li><li><p>SPOOLing 的组成</p><ul><li><p>建立在通道技术和多道程序技术的基础上</p></li><li><p>以高速随机外存（磁盘）为后援存储器</p></li><li><p>构成</p><ul><li>输入井和输出井</li><li>输入缓冲区和输出缓冲区</li><li>输入进程和输出进程</li><li>井管理程序</li></ul></li></ul></li><li><p>SPOOLing 系统的特点</p></li><li><p>假脱机打印机系统</p></li><li><p>守护进程（daemon）</p></li></ul></li></ul><h3 id="缓冲区管理"><a href="# 缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理 </h3><h3 id="磁盘存储器的性能和调度"><a href="# 磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a> 磁盘存储器的性能和调度</h3><ul><li><p>提高磁盘系统的性能的方式</p><ul><li>调度算法，减少寻道时间</li><li>提高 I/O 速度，提高对文件的访问速度</li><li>冗余技术，提高可靠性</li></ul></li><li><p>磁盘性能简述</p></li><li><p>调度算法</p><ul><li><p>先来先服务 FCFS</p><ul><li>请求进程少时</li></ul></li><li><p>最短寻道时间优先 SSTF</p><ul><li>不能保证平均寻道时间最短</li></ul></li><li><p>扫描（SCAN）算法</p><ul><li>考虑磁头移动方向</li><li>避免了“饥饿”现象</li><li>电梯调度算法</li></ul></li><li><p>循环扫描（CSCAN）算法</p><ul><li>减少延迟（越过请求）</li></ul></li><li><p>NStepSCAN 算法</p><ul><li>避免“磁臂粘着”现象</li></ul></li><li><p>FSCAN 算法</p></li></ul></li></ul><h2 id="文件管理"><a href="# 文件管理" class="headerlink" title="文件管理"></a>文件管理 </h2><h3 id="文件和文件系统"><a href="# 文件和文件系统" class="headerlink" title="文件和文件系统"></a> 文件和文件系统</h3><ul><li><p>FS 层次结构</p><ul><li><p>对象及其属性</p><ul><li>文件</li><li>目录</li><li>磁盘（磁带）存储空间</li></ul></li><li><p>对对象操纵和管理的软件集合</p><ul><li><p>文件管理系统的核心部分</p><ul><li>对文件存储空间的管理</li><li>对文件目录的管理</li><li>用于将文件的逻辑地址转换为物理地址的机制</li><li>对文件读和写的管理</li><li>对文件的共享和保护等功能</li></ul></li><li><p>与 FS 有关的软件分为四个层次</p><ul><li>I/O 控制层</li><li>基本文件系统层</li><li>基本 I/O 管理程序</li><li>逻辑文件系统</li></ul></li></ul></li><li><p>文件系统接口</p><ul><li>命令接口</li><li>程序接口</li></ul></li></ul></li></ul><h3 id="文件的逻辑结构"><a href="# 文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><ul><li><p>逻辑结构类型</p><ul><li><p>是否有结构</p><ul><li><p>有结构文件</p><ul><li>定长记录</li><li>变长记录</li></ul></li><li><p>无结构文件</p><ul><li>流式文件</li></ul></li></ul></li><li><p>组织方式</p><ul><li><p>顺序文件</p><ul><li>存取效率</li><li>顺序存储设备</li><li>查找开销大</li><li>增删记录</li></ul></li><li><p>索引文件</p></li><li><p>索引顺序文件</p></li></ul></li></ul></li><li><p>直接文件和 Hash 文件</p></li></ul><h3 id="文件目录"><a href="# 文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><ul><li><p>目录管理要求</p><ul><li>“按名存取”</li><li>提高对目录的检索速度</li><li>文件共享</li><li>允许文件重命名</li></ul></li><li><p>FCB 和索引结点</p><ul><li><p>文件目录：FCB 的有序集合。目录文件</p></li><li><p>FCB</p></li><li><p>索引结点</p><ul><li>减少目录占用盘块</li></ul></li></ul></li><li><p>简单文件目录</p><ul><li>单级</li><li>两级</li></ul></li><li><p>树形文件目录</p></li><li><p>目录查询技术</p></li></ul><h3 id="文件共享"><a href="# 文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><ul><li><p>DAG 目录</p><ul><li>不能共享新增的内容</li></ul></li><li><p>利用索引结点（硬链接）</p><ul><li>删除不便</li></ul></li><li><p>利用符号链接（Symbolic Linking）（软链接）</p><ul><li>访问删除文件时，删除符号链</li><li>会造成多次读盘</li><li>符号链占用索引结点</li></ul></li></ul><h3 id="文件保护"><a href="# 文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><ul><li><p>影响文件安全性的主要因素</p></li><li><p>采取措施</p></li><li><p>保护域</p></li><li><p>访问矩阵</p></li><li><p>访问矩阵的修改</p></li><li><p>访问矩阵的实现</p><ul><li><p>访问控制表（Access Control List）</p><ul><li>按列（对象）划分</li></ul></li><li><p>访问权限（Capabilities）表</p><ul><li>按行（域）划分</li></ul></li></ul></li></ul><h2 id="磁盘存储器管理"><a href="# 磁盘存储器管理" class="headerlink" title="磁盘存储器管理"></a>磁盘存储器管理 </h2><h3 id="对磁盘存储器管理的主要任务和要求"><a href="# 对磁盘存储器管理的主要任务和要求" class="headerlink" title="对磁盘存储器管理的主要任务和要求"></a> 对磁盘存储器管理的主要任务和要求</h3><ul><li>有效地利用存储空间</li><li>提高磁盘的 I/O 速度</li><li>提高磁盘系统的可靠性</li></ul><h3 id="外存的组织形式"><a href="# 外存的组织形式" class="headerlink" title="外存的组织形式"></a>外存的组织形式</h3><ul><li><p>连续组织方式</p><ul><li><p>目录</p><ul><li>file</li><li>start</li><li>length</li></ul></li><li><p>优点</p><ul><li>顺序访问容易</li><li>顺序访问速度快</li></ul></li><li><p>缺点</p><ul><li>外部碎片</li><li>事先知道文件长度</li><li>灵活插入和删除数据</li><li>动态增长</li></ul></li></ul></li><li><p>链接组织方式</p><ul><li><p>优点</p><ul><li>消除外部碎片</li><li>插入、删除、修改记录</li><li>动态增长</li></ul></li><li><p>隐式链接</p><ul><li><p>目录</p><ul><li>file</li><li>start</li><li>last</li></ul></li><li><p>缺点</p><ul><li>随机访问低效</li><li>可靠性</li><li>可按簇分配，但增大了内部碎片</li></ul></li></ul></li><li><p>显示链接</p><ul><li><p>FAT 表（File Allocation Table）</p></li><li><p>FAT 技术</p></li><li><p>NTFS 的文件组织方式</p><ul><li>簇为单位，块大小的无关性</li><li>卷为单位，MFT</li></ul></li></ul></li><li><p>优点</p><ul><li>提高了检索速度</li><li>减少了访问磁盘的次数</li></ul></li><li><p>缺点</p><ul><li>不支持高效直接存取</li><li>FAT 需要较大内存</li></ul></li></ul></li><li><p>索引组织方式</p><ul><li><p>单级索引组织方式</p><ul><li><p>只将某个文件的盘块号调入内存</p></li><li><p>将每个文件的盘块号集中放在一起，即索引块（表）</p></li><li><p>目录</p><ul><li>file</li><li>索引块号</li></ul></li><li><p>优点</p><ul><li>支持直接访问</li><li>无外部碎片</li></ul></li><li><p>缺点</p><ul><li>对于中、小型文件，索引块利用率低</li></ul></li></ul></li><li><p>多级索引组织方式</p><ul><li><p>优点</p><ul><li>避免索引块过多</li><li>加快了大型文件的查找速度</li></ul></li><li><p>缺点</p><ul><li>启动磁盘的次数和级数有关，不利于小文件</li></ul></li></ul></li><li><p>增量式索引组织方式</p></li></ul></li></ul><h3 id="文件存储空间的管理"><a href="# 文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h3><ul><li><p>引入</p><ul><li><p>文件所占盘块</p><ul><li>文件分配表</li></ul></li><li><p>可分配存储空间</p><ul><li>磁盘分配表（Disk Allocation Table）</li></ul></li><li><p>盘块分配和回收的手段</p></li></ul></li><li><p>空闲表法</p><ul><li>连续分配</li><li>分配速度高，减少 I/O 频率</li><li>用于对换空间和较小文件</li></ul></li><li><p>空闲链表法</p><ul><li>空闲盘块链</li><li>空闲盘区链</li></ul></li><li><p>位示图法</p><ul><li>NTFS</li></ul></li><li><p>成组链接法</p><ul><li><p>适用于大型文件系统</p></li><li><p>避免空闲表或空闲链表过长，将其结合</p></li><li><p>空闲盘块栈</p><ul><li>文件卷</li></ul></li></ul></li></ul><h3 id="提高 I-O 速度的途径"><a href="# 提高 I-O 速度的途径" class="headerlink" title="提高 I/O 速度的途径"></a>提高 I/O 速度的途径</h3><ul><li><p>改进文件的目录结构以及检索目录的方法，来减少对目录的查找时间</p><ul><li>索引结点</li><li>当前目录</li><li>多级目录</li></ul></li><li><p>选取好的文件存储结构，以提高对文件的访问速度</p><ul><li>顺序存储结构</li><li>索引结构</li></ul></li><li><p>提高磁盘的 I/O 速度，能将文件中的数据快速地从磁盘传送到内存中，或者相反</p><ul><li><p>磁盘高速缓存</p><ul><li>减少磁盘的启动次数</li></ul></li><li><p>提前读</p></li><li><p>延迟写</p></li><li><p>优化物理块的分布</p></li><li><p>虚拟盘</p></li><li><p>调度算法</p></li><li><p>RAID</p></li></ul></li><li><p>RAID</p></li></ul><h3 id="提高磁盘可靠性的技术"><a href="# 提高磁盘可靠性的技术" class="headerlink" title="提高磁盘可靠性的技术"></a>提高磁盘可靠性的技术 </h3><h3 id="数据一致性控制"><a href="# 数据一致性控制" class="headerlink" title="数据一致性控制"></a> 数据一致性控制</h3><ul><li><p>事务</p></li><li><p>检查点</p></li><li><p>并发控制</p></li><li><p>重复数据的数据一致性问题</p><ul><li><p>重复文件的一致性</p><ul><li>查找文件目录，获得其拷贝的索引结点号，修改文件</li><li>为新文件新建几个拷贝，取代原来的文件拷贝</li></ul></li><li><p>链接数一致性检查</p><ul><li>计数器表</li></ul></li></ul></li></ul><h2 id="小节"><a href="# 小节" class="headerlink" title="小节"></a>小节 </h2><h3 id="提高内存利用率的方法"><a href="# 提高内存利用率的方法" class="headerlink" title="提高内存利用率的方法"></a> 提高内存利用率的方法</h3><ul><li><p>整体对换（中级调度）</p></li><li><p>拼接（紧凑）</p></li><li><p>运行时动态链接</p></li><li><p>单一连续</p><ul><li><p>分区（多道批处理）</p><ul><li>分页 / 分段</li></ul></li></ul></li></ul><h3 id="SPOOLing 的工作原理"><a href="#SPOOLing 的工作原理" class="headerlink" title="SPOOLing 的工作原理"></a>SPOOLing 的工作原理 </h3><h3 id="提高 I-O 速度的途径 -1"><a href="# 提高 I-O 速度的途径 -1" class="headerlink" title="提高 I/O 速度的途径"></a> 提高 I/O 速度的途径 </h3><h3 id="算法"><a href="# 算法" class="headerlink" title="算法"></a> 算法</h3><ul><li>作业调度（四种）</li><li>进程调度（四 - 六种）</li><li>实时调度（三 - 八种）</li><li>避免死锁（一种）</li><li>动态分区分配算法（七种）</li><li>页面置换算法（六 - 七种）</li><li>磁盘调度算法（六种）</li></ul><h3 id="通过虚拟地址访问内存的优势"><a href="# 通过虚拟地址访问内存的优势" class="headerlink" title="通过虚拟地址访问内存的优势"></a>通过虚拟地址访问内存的优势</h3><ul><li>A program can use a contiguous range of virtual addresses to access a large memory buffer that is not contiguous in physical memory.</li><li>A program can use a range of virtual addresses to access a memory buffer that is larger than the available physical memory. As the supply of physical memory becomes small, the memory manager saves pages of physical memory (typically 4 kilobytes in size) to a disk file. Pages of data or code are moved between physical memory and the disk as needed.</li><li>The virtual addresses used by different processes are isolated from each other. The code in one process cannot alter the physical memory that is being used by another process or the operating system.</li></ul><p><em>XMind - Trial Version</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII 编码一览表</title>
      <link href="document/ascii-bian-ma-yi-lan-biao/"/>
      <url>document/ascii-bian-ma-yi-lan-biao/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="right"> 二进制 </th><th align="right"> 十进制 </th><th align="right"> 十六进制 </th><th> 字符 / 缩写 </th><th> 解释 </th></tr></thead><tbody><tr><td align="right">00 000  000</td><td align="right">0</td><td align="right">0</td><td>NUL (NULL)</td><td> 空字符 </td></tr><tr><td align="right">00 000 001</td><td align="right">1</td><td align="right">1</td><td>SOH  (Start Of Headling)</td><td> 标题开始 </td></tr><tr><td align="right">00 000 010</td><td align="right">2</td><td align="right">2</td><td>STX  (Start Of Text)</td><td> 正文开始 </td></tr><tr><td align="right">00 000 011</td><td align="right">3</td><td align="right">3</td><td>ETX  (End Of Text)</td><td> 正文结束 </td></tr><tr><td align="right">00 000 100</td><td align="right">4</td><td align="right">4</td><td>EOT  (End Of Transmission)</td><td> 传输结束 </td></tr><tr><td align="right">00 000 101</td><td align="right">5</td><td align="right">5</td><td>ENQ  (Enquiry)</td><td> 请求 </td></tr><tr><td align="right">00 000 110</td><td align="right">6</td><td align="right">6</td><td>ACK  (Acknowledge)</td><td> 回应 / 响应 / 收到通知 </td></tr><tr><td align="right">00 000 111</td><td align="right">7</td><td align="right">7</td><td>BEL  (Bell)</td><td> 响铃 </td></tr><tr><td align="right">00 001 000</td><td align="right">8</td><td align="right">8</td><td>BS  (Backspace)</td><td> 退格 </td></tr><tr><td align="right">00 001 001</td><td align="right">9</td><td align="right">9</td><td>HT  (Horizontal Tab)</td><td> 水平制表符 </td></tr><tr><td align="right">00 001 010</td><td align="right">10</td><td align="right">0A</td><td>LF/NL(Line  Feed/New Line)</td><td> 换行键 </td></tr><tr><td align="right">00 001 011</td><td align="right">11</td><td align="right">0B</td><td>VT  (Vertical Tab)</td><td> 垂直制表符 </td></tr><tr><td align="right">00 001 100</td><td align="right">12</td><td align="right">0C</td><td>FF/NP  (Form Feed/New Page)</td><td> 换页键 </td></tr><tr><td align="right">00 001 101</td><td align="right">13</td><td align="right">0D</td><td>CR  (Carriage Return)</td><td> 回车键 </td></tr><tr><td align="right">00 001 110</td><td align="right">14</td><td align="right">0E</td><td>SO  (Shift Out)</td><td> 不用切换 </td></tr><tr><td align="right">00 001 111</td><td align="right">15</td><td align="right">0F</td><td>SI  (Shift In)</td><td> 启用切换 </td></tr><tr><td align="right">00 010 000</td><td align="right">16</td><td align="right">10</td><td>DLE  (Data Link Escape)</td><td> 数据链路转义 </td></tr><tr><td align="right">00 010 001</td><td align="right">17</td><td align="right">11</td><td>DC1/XON</td><td> 设备控制 1/ 传输开始 </td></tr><tr><td align="right"></td><td align="right"></td><td align="right"></td><td>(Device  Control 1/Transmission On)</td><td></td></tr><tr><td align="right">00 010 010</td><td align="right">18</td><td align="right">12</td><td>DC2  (Device Control 2)</td><td> 设备控制 2</td></tr><tr><td align="right">00 010 011</td><td align="right">19</td><td align="right">13</td><td>DC3/XOFF</td><td> 设备控制 3/ 传输中断 </td></tr><tr><td align="right"></td><td align="right"></td><td align="right"></td><td>(Device  Control 3/Transmission Off)</td><td></td></tr><tr><td align="right">00 010 100</td><td align="right">20</td><td align="right">14</td><td>DC4  (Device Control 4)</td><td> 设备控制 4</td></tr><tr><td align="right">00 010 101</td><td align="right">21</td><td align="right">15</td><td>NAK  (Negative Acknowledge)</td><td> 无响应 / 非正常响应 / 拒绝接收 </td></tr><tr><td align="right">00 010 110</td><td align="right">22</td><td align="right">16</td><td>SYN  (Synchronous Idle)</td><td> 同步空闲 </td></tr><tr><td align="right">00 010 111</td><td align="right">23</td><td align="right">17</td><td>ETB  (End of Transmission Block)</td><td> 传输块结束 / 块传输终止 </td></tr><tr><td align="right">00 011 000</td><td align="right">24</td><td align="right">18</td><td>CAN  (Cancel)</td><td> 取消 </td></tr><tr><td align="right">00 011 001</td><td align="right">25</td><td align="right">19</td><td>EM  (End of Medium)</td><td> 已到介质末端 / 介质存储已满 / 介质中断 </td></tr><tr><td align="right">00 011 010</td><td align="right">26</td><td align="right">1A</td><td>SUB  (Substitute)</td><td> 替补 / 替换 </td></tr><tr><td align="right">00 011 011</td><td align="right">27</td><td align="right">1B</td><td>ESC  (Escape)</td><td> 逃离 / 取消 </td></tr><tr><td align="right">00 011 100</td><td align="right">28</td><td align="right">1C</td><td>FS  (File Separator)</td><td> 文件分割符 </td></tr><tr><td align="right">00 011 101</td><td align="right">29</td><td align="right">1D</td><td>GS  (Group Separator)</td><td> 组分隔符 / 分组符 </td></tr><tr><td align="right">00 011 110</td><td align="right">30</td><td align="right">1E</td><td>RS  (Record Separator)</td><td> 记录分离符 </td></tr><tr><td align="right">00 011 111</td><td align="right">31</td><td align="right">1F</td><td>US  (Unit Separator)</td><td> 单元分隔符 </td></tr><tr><td align="right">00 100 000</td><td align="right">32</td><td align="right">20</td><td>(Space)</td><td> 空格 </td></tr><tr><td align="right">00 100 001</td><td align="right">33</td><td align="right">21</td><td>!</td><td></td></tr><tr><td align="right">00 100 010</td><td align="right">34</td><td align="right">22</td><td>“</td><td></td></tr><tr><td align="right">00 100 011</td><td align="right">35</td><td align="right">23</td><td>#</td><td></td></tr><tr><td align="right">00 100 100</td><td align="right">36</td><td align="right">24</td><td>$</td><td></td></tr><tr><td align="right">00 100 101</td><td align="right">37</td><td align="right">25</td><td>%</td><td></td></tr><tr><td align="right">00 100 110</td><td align="right">38</td><td align="right">26</td><td>&amp;</td><td></td></tr><tr><td align="right">00 100 111</td><td align="right">39</td><td align="right">27</td><td></td><td></td></tr><tr><td align="right">00 101 000</td><td align="right">40</td><td align="right">28</td><td>(</td><td></td></tr><tr><td align="right">00 101 001</td><td align="right">41</td><td align="right">29</td><td>)</td><td></td></tr><tr><td align="right">00 101 010</td><td align="right">42</td><td align="right">2A</td><td>*</td><td></td></tr><tr><td align="right">00 101 011</td><td align="right">43</td><td align="right">2B</td><td>+</td><td></td></tr><tr><td align="right">00 101 100</td><td align="right">44</td><td align="right">2C</td><td>,</td><td></td></tr><tr><td align="right">00 101 101</td><td align="right">45</td><td align="right">2D</td><td>-</td><td></td></tr><tr><td align="right">00 101 110</td><td align="right">46</td><td align="right">2E</td><td>.</td><td></td></tr><tr><td align="right">00 101 111</td><td align="right">47</td><td align="right">2F</td><td>/</td><td></td></tr><tr><td align="right">00 110 000</td><td align="right">48</td><td align="right">30</td><td>0</td><td></td></tr><tr><td align="right">00 110 001</td><td align="right">49</td><td align="right">31</td><td>1</td><td></td></tr><tr><td align="right">00 110 010</td><td align="right">50</td><td align="right">32</td><td>2</td><td></td></tr><tr><td align="right">00 110 011</td><td align="right">51</td><td align="right">33</td><td>3</td><td></td></tr><tr><td align="right">00 110 100</td><td align="right">52</td><td align="right">34</td><td>4</td><td></td></tr><tr><td align="right">00 110 101</td><td align="right">53</td><td align="right">35</td><td>5</td><td></td></tr><tr><td align="right">00 110 110</td><td align="right">54</td><td align="right">36</td><td>6</td><td></td></tr><tr><td align="right">00 110 111</td><td align="right">55</td><td align="right">37</td><td>7</td><td></td></tr><tr><td align="right">00 111 000</td><td align="right">56</td><td align="right">38</td><td>8</td><td></td></tr><tr><td align="right">00 111 001</td><td align="right">57</td><td align="right">39</td><td>9</td><td></td></tr><tr><td align="right">00 111 010</td><td align="right">58</td><td align="right">3A</td><td>:</td><td></td></tr><tr><td align="right">00 111 011</td><td align="right">59</td><td align="right">3B</td><td>;</td><td></td></tr><tr><td align="right">00 111 100</td><td align="right">60</td><td align="right">3C</td><td>&lt;</td><td></td></tr><tr><td align="right">00 111 101</td><td align="right">61</td><td align="right">3D</td><td>=</td><td></td></tr><tr><td align="right">00 111 110</td><td align="right">62</td><td align="right">3E</td><td>&gt;</td><td></td></tr><tr><td align="right">00 111 111</td><td align="right">63</td><td align="right">3F</td><td>?</td><td></td></tr><tr><td align="right">01 000 000</td><td align="right">64</td><td align="right">40</td><td>@</td><td></td></tr><tr><td align="right">01 000 001</td><td align="right">65</td><td align="right">41</td><td>A</td><td></td></tr><tr><td align="right">01 000 010</td><td align="right">66</td><td align="right">42</td><td>B</td><td></td></tr><tr><td align="right">01 000 011</td><td align="right">67</td><td align="right">43</td><td>C</td><td></td></tr><tr><td align="right">01 000 100</td><td align="right">68</td><td align="right">44</td><td>D</td><td></td></tr><tr><td align="right">01 000 101</td><td align="right">69</td><td align="right">45</td><td>E</td><td></td></tr><tr><td align="right">01 000 110</td><td align="right">70</td><td align="right">46</td><td>F</td><td></td></tr><tr><td align="right">01 000 111</td><td align="right">71</td><td align="right">47</td><td>G</td><td></td></tr><tr><td align="right">01 001 000</td><td align="right">72</td><td align="right">48</td><td>H</td><td></td></tr><tr><td align="right">01 001 001</td><td align="right">73</td><td align="right">49</td><td>I</td><td></td></tr><tr><td align="right">01 001 010</td><td align="right">74</td><td align="right">4A</td><td>J</td><td></td></tr><tr><td align="right">01 001 011</td><td align="right">75</td><td align="right">4B</td><td>K</td><td></td></tr><tr><td align="right">01 001 100</td><td align="right">76</td><td align="right">4C</td><td>L</td><td></td></tr><tr><td align="right">01 001 101</td><td align="right">77</td><td align="right">4D</td><td>M</td><td></td></tr><tr><td align="right">01 001 110</td><td align="right">78</td><td align="right">4E</td><td>N</td><td></td></tr><tr><td align="right">01 001 111</td><td align="right">79</td><td align="right">4F</td><td>O</td><td></td></tr><tr><td align="right">01 010 000</td><td align="right">80</td><td align="right">50</td><td>P</td><td></td></tr><tr><td align="right">01 010 001</td><td align="right">81</td><td align="right">51</td><td>Q</td><td></td></tr><tr><td align="right">01 010 010</td><td align="right">82</td><td align="right">52</td><td>R</td><td></td></tr><tr><td align="right">01 010 011</td><td align="right">83</td><td align="right">53</td><td>S</td><td></td></tr><tr><td align="right">01 010 100</td><td align="right">84</td><td align="right">54</td><td>T</td><td></td></tr><tr><td align="right">01 010 101</td><td align="right">85</td><td align="right">55</td><td>U</td><td></td></tr><tr><td align="right">01 010 110</td><td align="right">86</td><td align="right">56</td><td>V</td><td></td></tr><tr><td align="right">01 010 111</td><td align="right">87</td><td align="right">57</td><td>W</td><td></td></tr><tr><td align="right">01 011 000</td><td align="right">88</td><td align="right">58</td><td>X</td><td></td></tr><tr><td align="right">01 011 001</td><td align="right">89</td><td align="right">59</td><td>Y</td><td></td></tr><tr><td align="right">01 011 010</td><td align="right">90</td><td align="right">5A</td><td>Z</td><td></td></tr><tr><td align="right">01 011 011</td><td align="right">91</td><td align="right">5B</td><td>[</td><td></td></tr><tr><td align="right">01 011 100</td><td align="right">92</td><td align="right">5C</td><td>\</td><td></td></tr><tr><td align="right">01 011 101</td><td align="right">93</td><td align="right">5D</td><td>]</td><td></td></tr><tr><td align="right">01 011 110</td><td align="right">94</td><td align="right">5E</td><td>^</td><td></td></tr><tr><td align="right">01 011 111</td><td align="right">95</td><td align="right">5F</td><td>_</td><td></td></tr><tr><td align="right">01 100 000</td><td align="right">96</td><td align="right">60</td><td>`</td><td></td></tr><tr><td align="right">01 100 001</td><td align="right">97</td><td align="right">61</td><td>a</td><td></td></tr><tr><td align="right">01 100 010</td><td align="right">98</td><td align="right">62</td><td>b</td><td></td></tr><tr><td align="right">01 100 011</td><td align="right">99</td><td align="right">63</td><td>c</td><td></td></tr><tr><td align="right">01 100 100</td><td align="right">100</td><td align="right">64</td><td>d</td><td></td></tr><tr><td align="right">01 100 101</td><td align="right">101</td><td align="right">65</td><td>e</td><td></td></tr><tr><td align="right">01 100 110</td><td align="right">102</td><td align="right">66</td><td>f</td><td></td></tr><tr><td align="right">01 100 111</td><td align="right">103</td><td align="right">67</td><td>g</td><td></td></tr><tr><td align="right">01 101 000</td><td align="right">104</td><td align="right">68</td><td>h</td><td></td></tr><tr><td align="right">01 101 001</td><td align="right">105</td><td align="right">69</td><td>i</td><td></td></tr><tr><td align="right">01 101 010</td><td align="right">106</td><td align="right">6A</td><td>j</td><td></td></tr><tr><td align="right">01 101 011</td><td align="right">107</td><td align="right">6B</td><td>k</td><td></td></tr><tr><td align="right">01 101 100</td><td align="right">108</td><td align="right">6C</td><td>l</td><td></td></tr><tr><td align="right">01 101 101</td><td align="right">109</td><td align="right">6D</td><td>m</td><td></td></tr><tr><td align="right">01 101 110</td><td align="right">110</td><td align="right">6E</td><td>n</td><td></td></tr><tr><td align="right">01 101 111</td><td align="right">111</td><td align="right">6F</td><td>o</td><td></td></tr><tr><td align="right">01 110 000</td><td align="right">112</td><td align="right">70</td><td>p</td><td></td></tr><tr><td align="right">01 110 001</td><td align="right">113</td><td align="right">71</td><td>q</td><td></td></tr><tr><td align="right">01 110 010</td><td align="right">114</td><td align="right">72</td><td>r</td><td></td></tr><tr><td align="right">01 110 011</td><td align="right">115</td><td align="right">73</td><td>s</td><td></td></tr><tr><td align="right">01 110 100</td><td align="right">116</td><td align="right">74</td><td>t</td><td></td></tr><tr><td align="right">01 110 101</td><td align="right">117</td><td align="right">75</td><td>u</td><td></td></tr><tr><td align="right">01 110 110</td><td align="right">118</td><td align="right">76</td><td>v</td><td></td></tr><tr><td align="right">01 110 111</td><td align="right">119</td><td align="right">77</td><td>w</td><td></td></tr><tr><td align="right">01 111 000</td><td align="right">120</td><td align="right">78</td><td>x</td><td></td></tr><tr><td align="right">01 111 001</td><td align="right">121</td><td align="right">79</td><td>y</td><td></td></tr><tr><td align="right">01 111 010</td><td align="right">122</td><td align="right">7A</td><td>z</td><td></td></tr><tr><td align="right">01 111 011</td><td align="right">123</td><td align="right">7B</td><td>{</td><td></td></tr><tr><td align="right">01 111 100</td><td align="right">124</td><td align="right">7C</td><td>|</td><td></td></tr><tr><td align="right">01 111 101</td><td align="right">125</td><td align="right">7D</td><td>}</td><td></td></tr><tr><td align="right">01 111 110</td><td align="right">126</td><td align="right">7E</td><td>~</td><td></td></tr><tr><td align="right">01 111 111</td><td align="right">127</td><td align="right">7F</td><td>DEL  (Delete)</td><td> 删除 </td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
